---
id: wrapping-an-api-in-a-component
title: Envolver una API en un componente
description: Aprenda a escribir un componente personalizado que envuelve una API de terceros basada en HTTP.
---

import Screenshot from "@site/src/components/screenshot";

Los autores de componentes suelen ser solicitados para desarrollar un componente que implemente una serie de llamadas API para alg√∫n servicio de terceros (o posiblemente la API de su propia empresa).
Si la API para la que est√°s creando un componente tiene una especificaci√≥n OpenAPI o WSDL, puedes hacer que `prism` [genere un componente](custom-components/writing-custom-components.mdx#custom-components-from-wsdls-or-openapi-specs) basado en tu archivo de especificaci√≥n YAML, JSON o XML.

Sin embargo, si tu API no tiene una especificaci√≥n OpenAPI o WSDL, o si simplemente quieres implementar acciones para un peque√±o grupo de puntos finales, tenemos algunas "mejores pr√°cticas" que puedes seguir para desarrollar un componente personalizado que implemente esos puntos finales.
El c√≥digo de nuestro componente personalizado est√° disponible en [GitHub](https://github.com/-io/examples/tree/main/components/acmeerp).
Vamos a profundizar en el c√≥digo aqu√≠.

## Especificaciones de nuestros componentes

Para el tutorial de hoy, supongamos que estamos escribiendo un componente para "Acme ERP" - un sistema ERP ficticio, y nos gustar√≠a implementar acciones para un subconjunto de puntos finales que ofrece la API de Acme ERP.
Nos han entregado algunas especificaciones para nuestro componente:

- Cada cliente tiene instancias distintas de Acme ERP, por lo que el punto final de la API es diferente para cada cliente.
- Los clientes se autentican ingresando una clave API que generan.
- Para nuestra primera integraci√≥n, hay cuatro puntos finales para los que queremos acciones:
  - **Listar Todos los √çtems**: Esta es una llamada GET al punto final `/items/` de la API que devuelve un array de √≠tems en nuestro inventario.
  - **Obtener √çtem**: Esta es una llamada GET a `/items/{ ID_√çTEM }` y obtiene un √∫nico √≠tem de nuestro inventario por ID.
  - **Agregar √çtem**: Esta es una llamada POST a `/items/` para agregar un √≠tem a nuestro inventario.
  - **Eliminar √çtem**: Esta es una llamada DELETE a `/items/{ ID_√çTEM }` para eliminar un √≠tem del inventario.

## Inicializaci√≥n del componente

Como cualquier nuevo componente personalizado, podemos crear nuestro nuevo componente utilizando un subcomando de [Prism](cli/cli-usage.mdx):

```bash title="Inicializar nuestro componente"
$ prism components:init acmeerp
Creating component directory for "acmeerp"...

"acmeerp" is ready for development.
To install dependencies, run either "npm install" or "yarn install"
To test the component, run "npm run test" or "yarn test"
To build the component, run "npm run build" or "yarn build"
To publish the component, run "prism components:publish"

Para obtener documentaci√≥n sobre la creaci√≥n de componentes personalizados, visite https://.io/docs/custom-components/writing-custom-components/
```

Luego, instalar√© las dependencias de mi paquete usando `yarn` (aunque tambi√©n puedes usar `npm`):

```bash title="Instalar dependencias de paquetes"
$ yarn
yarn install v1.22.10
[1/4] üîç  Resolving packages...
[2/4] üöö  Fetching packages...
[3/4] üîó  Linking dependencies...
[4/4] üî®  Building fresh packages...
success Saved lockfile.
‚ú®  Done in 7.48s.
```

No voy a implementar ning√∫n desencadenador personalizado con este componente (si est√°s interesado en escribir desencadenadores, consulta [esta gu√≠a r√°pida](quickstarts/writing-a-trigger.mdx)), as√≠ que voy a eliminar `src/triggers.ts` y en `src/index.ts` eliminar√© las l√≠neas relacionadas con los desencadenadores.
Aprovechando la oportunidad, dar√© a mi componente una etiqueta y una descripci√≥n adecuadas:

```typescript {3,15} title="Eliminar la repetici√≥n de disparadores"
import { component } from "@-io/spectral";
import actions from "./actions";
import triggers from "./triggers";
import connections from "./connections";

export default component({
  key: "acmeerp",
  public: false,
  display: {
    label: "Acme ERP",
    description: "Manage inventory in Acme ERP",
    iconPath: "icon.png",
  },
  actions,
  triggers,
  connections,
});
```

Tambi√©n eliminar√© `src/index.test.ts`, ya que implementar√© pruebas unitarias m√°s adelante.

## Creaci√≥n de un cliente HTTP compartido

Nuestro componente necesita comunicarse con un punto final variable y debe aceptar una clave API.
Por lo tanto, nuestras conexiones deben contener tanto la informaci√≥n del punto final como las credenciales.
Para manejar esas cosas, crearemos una funci√≥n que tome una conexi√≥n y devuelva un cliente HTTP apuntando a ese punto final.
Realmente nos gusta [Axios](https://axios-http.com/), pero puedes usar otra biblioteca de cliente HTTP si prefieres.

```bash title="A√±adir Axios a nuestro proyecto"
$ yarn add axios
yarn add v1.22.10
[1/4] üîç  Resolving packages...
[2/4] üöö  Fetching packages...
[3/4] üîó  Linking dependencies...
[4/4] üî®  Building fresh packages...

success Saved lockfile.
success Saved 2 new dependencies.
info Direct dependencies
info All dependencies
‚îú‚îÄ axios@0.24.0
‚îî‚îÄ follow-redirects@1.14.5
‚ú®  Done in 6.47s.
```

Primero vamos a crear una `conexi√≥n`, que contendr√° la informaci√≥n necesaria para conectarse a Acme ERP: la URL √∫nica del endpoint del cliente y la clave API del cliente.

```typescript title="src/connections.ts"
import { connection } from "@-io/spectral";

// Crear una conexi√≥n que contenga una URL de punto final de API
// y una clave API.
export const apiKeyConnection = connection({
  key: "apiKey",
  label: "Acme Connection",
  comments: "Acme Connection",
  inputs: {
    endpoint: {
      label: "Acme Endpoint URL",
      placeholder: "Acme Endpoint URL",
      type: "string",
      required: true,
      comments: "Acme API Endpoint URL",
      default: "https://my-json-server.typicode.com/-io/placeholder-data",
      example: "https://my-company.api.acme.com/",
    },
    apiKey: {
      label: "Acme API Key",
      placeholder: "Acme API Key",
      type: "password",
      required: true,
      comments: "Generate at https://app.acme.com/settings/api-keys",
    },
  },
});

export default [apiKeyConnection];
```

A continuaci√≥n, crearemos una funci√≥n de ayuda, `getAcmeErpClient`, que tomar√° una entrada de conexi√≥n y crear√° un cliente HTTP apuntando a la URL del punto final de la conexi√≥n y autenticado con la clave API de la conexi√≥n.
Vamos a colocar este c√≥digo en un nuevo archivo llamado `auth.ts`:

```typescript title="src/auth.ts"
import axios from "axios";
import { Connection, util } from "@-io/spectral";

export function getAcmeErpClient(acmeConnection: Connection) {
  const { apiKey, endpoint } = acmeConnection.fields;

  // Devuelve un cliente HTTP que ha sido configurado para apuntar
  // hacia la URL del endpoint, y pasa una clave API como cabecera
  return axios.create({
    baseURL: util.types.toString(endpoint),
    headers: {
      Accept: "application/json", // Our API returns JSON
      Authorization: `Bearer ${apiKey}`,
    },
    maxContentLength: Infinity,
    maxBodyLength: Infinity,
  });
}
```

Ahora, cada una de nuestras acciones simplemente necesita pasar una conexi√≥n a la funci√≥n `getAcmeErpClient`, y podr√°n realizar llamadas HTTP a la API de Acme ERP.

Si construimos y publicamos este componente ahora, podemos crear una nueva variable de configuraci√≥n de conexi√≥n para nuestra integraci√≥n y completar nuestra clave API y la URL del punto final:

<Screenshot
  filename="quickstarts/wrapping-an-api-in-a-component/configure-connection.png"
  alt="Establezca la clave API y el punto final para Acme ERP Inventory en el dise√±ador de integraci√≥n"
  maxWidth="700px"
/>

## Escribir algunas acciones

Ahora es el momento de implementar nuestras acciones.
Recuerda, queremos crear cuatro acciones que enumeren todos los elementos en nuestro inventario, enumeren un elemento espec√≠fico, eliminen un elemento espec√≠fico y agreguen un elemento a nuestro inventario.

### Acci√≥n de listar todos los elementos

Comencemos con la acci√≥n "listar todos los elementos".
Esta acci√≥n tomar√° una √∫nica entrada: la conexi√≥n que acabamos de definir.

Mantengamos organizadas nuestras entradas, as√≠ que crearemos un nuevo archivo, `src/inputs.ts`, con esa √∫nica entrada por ahora que representa nuestra conexi√≥n (el punto final de la API del cliente y la clave API).
En la parte superior del archivo, importaremos la funci√≥n de tipo `input` de nuestra [biblioteca de SDK de componente personalizado](spectral/custom-component-library.mdx):

```typescript title="src/inputs.ts - Endpoint URL Input"
import { input } from "@-io/spectral";

export const connectionInput = input({
  label: "Acme ERP",
  required: true,
  type: "connection",
});
```

A continuaci√≥n, vamos a reemplazar el contenido de `src/actions.ts`.
Importaremos las funciones `action` y helper `util` de nuestro componente SDK personalizado, nuestra entrada de `inputs.ts`, y la informaci√≥n de autenticaci√≥n y cliente HTTP de `auth.ts`.
A continuaci√≥n, a√±adiremos una definici√≥n para nuestra acci√≥n "list all items":

```typescript title="src/actions.ts - Lista de todos los puntos Acci√≥n"
import { action } from "@-io/spectral";
import { getAcmeErpClient } from "./auth";
import { connectionInput } from "./inputs";

const listAllItems = action({
  display: {
    label: "List All Items",
    description: "List all items in our inventory",
  },
  inputs: {
    // Declarar una entrada para esta acci√≥n
    acmeConnection: connectionInput,
  },
  perform: async (context, { acmeConnection }) => {
    // Inicializar nuestro cliente HTTP
    const acmeErpClient = getAcmeErpClient(acmeConnection);

    // Realice una llamada GET s√≠ncrona a "{ endpoint }/items":
    const response = await acmeErpClient.get("/items/");

    // Devolver los datos obtenidos
    return { data: response.data };
  },
  // Mostrar una carga √∫til de ejemplo en la interfaz de usuario:
  examplePayload: {
    data: [
      {
        id: 1,
        name: "Widgets",
        quantity: 20,
      },
      {
        id: 2,
        name: "Whatsits",
        quantity: 100,
      },
    ],
  },
});
```

En este punto podemos ejecutar `yarn build` y `prism components:publish` para publicar nuestro componente de acci√≥n √∫nica en .
Si a√±adimos nuestra acci√≥n a una integraci√≥n, podemos ver que el paso toma la entrada de conexi√≥n que especificamos:

<Screenshot
  filename="quickstarts/wrapping-an-api-in-a-component/first-action-inputs.png"
  alt="Acme ERP - Listar todos los elementos en el dise√±ador de integraci√≥n"
  maxWidth="850px"
/>

Tambi√©n podemos hacer referencia a la carga √∫til de ejemplo que declara nuestra acci√≥n en un paso posterior:

<Screenshot
  filename="quickstarts/wrapping-an-api-in-a-component/first-action-results.png"
  alt="Acme ERP - Escribir mensaje de registro en el dise√±ador de integraci√≥n"
  maxWidth="850px"
/>

### Obtener acci√≥n

A continuaci√≥n, vamos a crear otra acci√≥n que obtenga un elemento espec√≠fico del inventario de nuestra API.
Esta acci√≥n reutilizar√° la misma entrada `connectionInput` que declaramos anteriormente, y tambi√©n requerir√° una entrada `itemIdInput`, para especificar el ID del elemento que queremos obtener:

```typescript title="src/inputs.ts - Entrada de ID de art√≠culo"
export const itemIdInput = input({
  label: "Item ID",
  required: true,
  type: "string",
});
```

La acci√≥n "obtener elemento" ser√° muy similar a la acci√≥n anterior: inicializar√° un cliente HTTP y devolver√° algunos datos.
La l√≥gica de `display`, `inputs`, `perform` y `examplePayload` diferir√° ligeramente, pero la mayor parte de la acci√≥n ser√° igual que antes:

```typescript title="src/actions.ts - Obtener acci√≥n"
import { connectionInput, itemIdInput } from "./inputs";

// ...

const getItem = action({
  display: {
    label: "Get Item",
    description: "Get an Item by ID",
  },
  inputs: {
    acmeConnection: connectionInput,
    itemId: itemIdInput,
  },
  perform: async (context, { acmeConnection, itemId }) => {
    const acmeErpClient = getAcmeErpClient(acmeConnection);
    const response = await acmeErpClient.get(`/items/${itemId}`);
    return { data: response.data };
  },
  examplePayload: {
    data: {
      id: 1,
      name: "Widgets",
      quantity: 20,
    },
  },
});

export default { getItem, listAllItems };
```

### Acci√≥n de eliminar elemento

En este punto, "repetimos el proceso": la acci√≥n "eliminar un elemento" obtendr√° un cliente HTTP, enviar√° una solicitud HTTP DELETE a un punto final y, esta vez, no devolver√° nada (ya que un DELETE de un elemento en nuestra API no devuelve nada).
Nuestra acci√≥n "eliminar un elemento" tomar√° una URL de punto final y un ID de elemento, al igual que la acci√≥n "obtener un elemento":

```typescript title="src/actions.ts - Eliminar un elemento Acci√≥n"
const deleteItem = action({
  display: {
    label: "Delete Item",
    description: "Delete an Item by ID",
  },
  inputs: {
    acmeConnection: connectionInput,
    itemId: itemIdInput,
  },
  perform: async (context, { acmeConnection, itemId }) => {
    const acmeErpClient = getAcmeErpClient(acmeConnection);
    const response = await acmeErpClient.delete(`/items/${itemId}`);
    return { data: null };
  },
});

export default { deleteItem, getItem, listAllItems };
```

### A√±adir una acci√≥n de art√≠culo

La acci√≥n "agregar un elemento" tiene un par de diferencias sutiles de las otras tres acciones:

- Toma entradas adicionales (`nombre` y `cantidad`).
  Estas entradas no son compartidas por otras acciones, por lo que podemos definirlas en l√≠nea.
- La llamada HTTP que usamos es una llamada POST, y pasamos nuestras entradas `nombre` y `cantidad` a la API como par√°metros POST.

El reinicio de la acci√≥n es muy similar al de las acciones anteriores:

```typescript title="src/actions.ts - A√±adir acci√≥n"
const addItem = action({
  display: {
    label: "Add Item",
    description: "Add an Item to Inventory",
  },
  // Podemos definir algunas entradas en l√≠nea si no se reutilizan:
  inputs: {
    acmeConnection: connectionInput,
    name: input({ label: "Item Name", type: "string" }),
    quantity: input({ label: "Item Quantity", type: "string" }),
  },
  perform: async (context, { acmeConnection, name, quantity }) => {
    const acmeErpClient = getAcmeErpClient(acmeConnection);
    const response = await acmeErpClient.post("/items/", {
      name,
      quantity,
    });
    return { data: response.data };
  },
  // Esta llamada a la API devuelve el objeto item que se ha creado:
  examplePayload: {
    data: {
      id: 1,
      name: "Widgets",
      quantity: 20,
    },
  },
});

export default { addItem, deleteItem, getItem, listAllItems };
```

## Pruebas unitarias de nuestro componente

Ahora que hemos implementado nuestras cuatro acciones para nuestro componente, agreguemos algunas [pruebas unitarias](custom-components/writing-custom-components.mdx#pruebas-unitarias-para-componentes-personalizados) para verificar que nuestras acciones devuelven lo que esperamos que devuelvan.
Para hacer eso, crearemos un nuevo archivo, `src/actions.test.ts`.

Podemos importar una funci√≥n auxiliar del SDK - `invoke`.
Luego, podemos importar las acciones que queremos probar (probaremos "agregar un elemento" aqu√≠) y podemos invocar la acci√≥n y verificar que el `resultado` que recibimos sea el que esperamos:

```typescript title="src/actions.test.ts - Prueba unitaria de la acci√≥n A√±adir elemento"
import { invoke, createConnection } from "@-io/spectral/dist/testing";
import { apiKeyConnection } from "./connections";
import actions from "./actions";

const acmeConnection = createConnection(apiKeyConnection, {
  endpoint: "https://my-json-server.typicode.com/-io/placeholder-data",
  apiKey: process.env.ACME_ERP_API_KEY, // Get API key from an environment variable
});

describe("probar la acci√≥n de a√±adir elemento", () => {
  test("comprobar que nos devuelven lo que enviamos", async () => {
    const name = "widgets";
    const quantity = 123;
    const { result } = await invoke(
      actions.addItem, // Invocar la acci√≥n "addItem
      { acmeConnection, name, quantity } // Pasar algunas entradas que declaramos
    );
    expect(result.data.name).toEqual(name); // Comprobar que la respuesta ten√≠a el mismo nombre de elemento
    expect(result.data.quantity).toEqual(quantity); // Comprobar que la respuesta ten√≠a la misma cantidad de art√≠culos
  });
});
```