---
id: integration-triggers
title: Cómo utilizar los desencadenantes de integración
description: Los disparadores de integración permiten definir cuándo se ejecuta una instancia. Los activadores programados y los activadores webhook son los más comunes. Aprenda a utilizarlos.
---

import Screenshot from "@site/src/components/screenshot";
import Vimeo from "@site/src/components/vimeo";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Los desencadenadores de integración te permiten definir _cuándo_ debe ejecutarse una instancia. Hay varios tipos de desencadenadores, siendo los más comúnmente utilizados los [desencadenadores programados](#scheduled-triggers) y los [desencadenadores de webhook](#webhook-triggers). Muchos componentes incluyen desencadenadores que realizan acciones como validar cargas útiles de webhook, preprocesar datos o devolver respuestas personalizadas al llamante del webhook. También puedes configurar un [desencadenador de implementación](#instance-deploy-trigger) que se ejecuta cuando tu integración se implementa en un cliente.


- Si estás integrando con una aplicación o servicio en particular, y ese servicio tiene un componente con un desencadenador, utiliza ese desencadenador.
- Si deseas que tu integración se ejecute de forma regular y predefinida, debes usar un desencadenador programado.
- Si deseas invocar tu integración desde otro sistema que pueda realizar llamadas HTTP, debes usar un desencadenador de webhook.
- Si tienes un flujo que deseas ejecutar cuando se implementa una instancia, utiliza un desencadenador de implementación.


Si tu integración tiene varios [flujos](building-integrations.mdx#flows-in-integrations), cada flujo tiene su propio desencadenador (y, por lo tanto, su propia URL de webhook o programación).

Siempre puedes cambiar el desencadenador que utiliza tu flujo haciendo clic en el desencadenador y luego en el botón **CAMBIAR DESENCADENADOR** en el panel que aparece.


## Activadores programados

Los desencadenadores programados te permiten crear una programación regular para dictar cada cuánto debe ejecutarse tu integración.
Esto es útil si tienes una integración que debe activarse de manera consistente en un momento específico.
Puedes configurar tu integración para que se ejecute al mismo tiempo para todos los clientes, o puedes establecer programaciones específicas para cada cliente.

Para configurar la misma programación para todos los clientes, haz clic en el desencadenador de la integración, abre la pestaña **Programación** e ingresa la programación que deseas para tu integración.

Puede configurar su integración para que se ejecute cada X minutos, horas, días o semanas:

<Screenshot
  filename="integrations/schedule-trigger/static-schedule.png"
  maxWidth="600px"
  alt="Activar la integración estática en la aplicación"
/>

Alternativamente, puedes seleccionar **Personalizado** y proporcionar una [cadena cron](https://es.wikipedia.org/wiki/Cron).
Por ejemplo, un desencadenador de `*/5 8-16 * * 1-5` haría que tu integración se ejecute cada cinco minutos durante el horario laboral (8:00-16:55), de lunes a viernes.
Para obtener ayuda con el cálculo de una programación cron, consulta esta [Calculadora Cron](https://crontab.guru/).

Para configurar programaciones específicas para cada cliente, primero crea una variable de configuración de tipo **Programación** haciendo clic en el botón **Asistente de Configuración**.
Puedes darle el nombre que elijas a tu variable de configuración:


<Screenshot
  filename="integrations/schedule-trigger/schedule-config-variable.png"
  maxWidth="700px"
  alt="Configurar el activador de integración para utilizar una variable de configuración en la aplicación"
/>

A continuación, haga clic en su activador de integración y haga referencia a la **Variable de configuración** que ha creado:

<Screenshot
  filename="integrations/schedule-trigger/config-driven-schedule.png"
  maxWidth="550px"
  alt="Establezca la variable de configuración para el activador de integración en la aplicación"
/>

Cuando su equipo de despliegue de integraciones despliega posteriormente una instancia de su integración, puede configurar un calendario personalizado para esa instancia.

## Activadores de webhooks

Los desencadenadores de Webhook te permiten ejecutar una instancia particular o [flujo](building-integrations.mdx#flows-in-integrations) de una instancia realizando una solicitud HTTP POST, PUT, PATCH, DELETE o GET a la URL del webhook.
Esto es útil si deseas que una aplicación externa invoque una integración cuando ocurre algo dentro de esa aplicación externa.
La aplicación externa puede reunir algunos datos y enviar esos datos a una URL de webhook mediante una solicitud HTTP.


Por ejemplo, el software de terceros podría invocar una instancia con una carga JSON cada vez que se complete un trabajo en la aplicación de terceros, de esta manera:

```bash
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --data '{"renderId":51266,"s3Bucket":"test-customer-renders","status":"complete"}' \
  --header "Content-Type: application/json"
```

Ten en cuenta que la carga útil de la solicitud está disponible al hacer referencia al desencadenador de la integración, como se muestra en la captura de pantalla a continuación.
Luego, los pasos pueden hacer referencia a los datos de la carga útil del webhook a través de los resultados del desencadenador.
Las cabeceras están disponibles a través de `results.headers` y los datos del cuerpo están disponibles a través de `results.body.data`:


<Screenshot
  filename="integrations/webhook-trigger-payload.png"
  alt="Activar el webhook mediante una solicitud POST en la aplicación"
/>

:::note Se admite el verbo GET
Puedes usar el verbo GET para invocar una instancia, pero ten en cuenta que el verbo GET no te permite enviar datos con tu petición.
Si necesita enviar datos con su petición, utilice los verbos POST, PUT, DELETE o PATCH.

El verbo GET se introdujo porque algunas aplicaciones envían una petición GET cuando se configura un webhook para verificar que el punto final del webhook está listo para recibir peticiones.
:::

### Respuestas de activación de webhooks

Por defecto, los activadores de webhook proporcionan una respuesta HTTP de código 200 ("OK") a quienes llaman al webhook.
El cuerpo de la respuesta contiene un ID de ejecución, que puede utilizarse posteriormente para obtener registros y resultados de pasos de la API.
La respuesta tiene el siguiente aspecto

```bash
curl \
  --data '{}' \
  --header "Content-Type: application/json" \
  'https://hooks..io/trigger/EXAMPLE=='

{"executionId":"SW5zdGFuY2VFeGVjdXRpb25SZXN1bHQ6OTdiNWQxYmEtZGUyZi00ZDY4LWIyMTgtMDFlZGMwMTQxNTM5"}
```

Puede personalizar la respuesta haciendo clic en el activador del webhook de integración y seleccionando un código HTTP, un cuerpo de respuesta o un tipo de contenido de respuesta diferentes:

<Screenshot
  filename="integrations/webhook-trigger-response.png"
  maxWidth="500px"
  alt="Personalizar el código de respuesta del desencadenador webhook en la aplicación"
/>

### Otras respuestas de activación de webhooks

Puede encontrar otras respuestas a su solicitud de activación de webhook.

#### HTTP 303 Ver Otro / Redirigir a Cubo de Resultados S3

Cuando se invoca tu desencadenador de webhook de forma [sincrónica](#synchronous-and-asynchronous-integrations), tu cliente HTTP envía una solicitud y espera a que la integración termine de ejecutarse antes de cerrar la solicitud.
responde a la solicitud con una redirección HTTP 303, redirigiendo tu cliente HTTP a un objeto en un cubo de Amazon S3 que contiene los resultados del último paso de tu integración.

Asegúrate de que tu cliente HTTP siga las redirecciones (para `curl`, debes agregar la bandera `--location`).


```txt title="Petición síncrona redirigida"
$ curl 'https://hooks..io/trigger/example==' --location -v

...

< HTTP/2 303
< content-type: application/json
< content-length: 0
< location: https://example.s3.us-east-2.amazonaws.com/example
< date: Wed, 28 Sep 2022 19:42:24 GMT
< x-amzn-requestid: 4c2a5179-89a2-4351-afe0-336df2cdef11
< access-control-allow-headers: Accept,CloudFront-Forwarded-Proto,CloudFront-Is-Desktop-Viewer,CloudFront-Is-Mobile-Viewer,CloudFront-Is-SmartTV-Viewer,CloudFront-Is-Tablet-Viewer,CloudFront-Viewer-ASN,CloudFront-Viewer-Country,Host,User-Agent,Via,X-Amz-Cf-Id,X-Amzn-Trace-Id,X-Forwarded-For,X-Forwarded-Port,X-Forwarded-Proto
< x-amz-apigw-id: ZL6A7GegCYcF5Ew=
< -executionid: SW5zdGFuY2VFeGVjdXRpb25SZXN1bHQ6NGVjMTJiNWMtODk2ZC00ZGJiLThjZDgtZWUwYzNlMDE4OTBh
< access-control-allow-methods: GET
< x-amzn-trace-id: Root=1-6334a39f-0f975a9a7bb343c768645c36;Sampled=1
< x-cache: Miss from cloudfront
< via: 1.1 d67353af1bc95b93fa6102d888271954.cloudfront.net (CloudFront)
< x-amz-cf-pop: ORD58-P7
< x-amz-cf-id: xraa6hPBPc_texazIJXdKgavfwVRMW2oV85GqwCx6xUkUck7MxGKPg==
<

...

* Connection #0 to host hooks..io left intact
* Issue another request to this URL: 'https://example.s3.us-east-2.amazonaws.com/example'

...

< HTTP/1.1 200 OK
< x-amz-id-2: zx2ZHsGlC/Szu3HCp7xjRAVDALsEdQ/TJ5x/MkcbFkAB8DjLmRJOWCyTGmpI93UhdpqeYxt7hVo=
< x-amz-request-id: SE5KV3CJ5AXCYGZA
< Date: Wed, 28 Sep 2022 19:42:25 GMT
< Last-Modified: Wed, 28 Sep 2022 19:42:25 GMT
< x-amz-expiration: expiry-date="Sat, 29 Oct 2022 00:00:00 GMT", rule-id="expire-old-step-results"
< ETag: "083be81885a78809b54f4deead0e6c24"
< x-amz-server-side-encryption: AES256
< x-amz-version-id: 7bc_zpEQGmpc_stsaC.9vcF1DqxzXWx.
< Accept-Ranges: bytes
< Content-Type: application/octet-stream
< Server: AmazonS3
< Content-Length: 11
<
* Connection #1 to host payload-bucket20200616192411543900000009.s3.us-east-2.amazonaws.com left intact
{"item":"Widgets","quantity":5}
```

:::caution Evita combinar --location y --request POST
Combinar `--location` y una bandera explícita `--request POST` (o `-X POST`) en el mismo comando `curl` puede tener consecuencias no deseadas.
`curl` será redirigido a un cubo de S3, pero intentará realizar una solicitud `POST` (en lugar de una solicitud `GET`) al cubo de S3.
Esto resulta en que S3 responda con un error `SignatureDoesNotMatch`.

Verás el error de S3 dentro de [Postman](https://www.postman.com/) si habilitas la opción **Seguir método HTTP original**.
Mantén esa opción sin marcar.


<Screenshot
  filename="integrations/postman-redirect-warning.png"
  alt="Evite especificar el método HTTP con las redirecciones"
/>

:::

#### HTTP 400 Petición errónea

Verá una respuesta HTTP 400 por una de dos razones:

- Si tu solicitud estaba mal formada (por ejemplo, tienes un encabezado `content-type: application/json`, pero los datos que enviaste no eran JSON válido).


  ```txt title="Carga malformada"
  $ curl 'https://hooks.treece.-dev.io/trigger/example==' -v \
  --data "{bad-data" \
  --header "content-type: application/json"

  ...

  < HTTP/2 400
  < content-type: application/json
  < content-length: 44
  < date: Wed, 28 Sep 2022 19:47:09 GMT
  < x-amzn-requestid: 64a06065-c2d5-4d1b-8188-1513f072cb8e
  < access-control-allow-headers: Accept,CloudFront-Forwarded-Proto,CloudFront-Is-Desktop-Viewer,CloudFront-Is-Mobile-Viewer,CloudFront-Is-SmartTV-Viewer,CloudFront-Is-Tablet-Viewer,CloudFront-Viewer-ASN,CloudFront-Viewer-Country,content-type,Host,User-Agent,Via,X-Amz-Cf-Id,X-Amzn-Trace-Id,X-Forwarded-For,X-Forwarded-Port,X-Forwarded-Proto
  < x-amz-apigw-id: ZL6tYEjPCYcFmMA=
  < -executionid: SW5zdGFuY2VFeGVjdXRpb25SZXN1bHQ6YmIwZmQwMjgtYmRlOS00NDFhLTg4ZTYtNjcwZDlkMDY2NjZm
  < access-control-allow-methods: POST
  < x-amzn-trace-id: Root=1-6334a4bb-5a02f67725c134b505472c11;Sampled=1
  < x-cache: Error from cloudfront
  < via: 1.1 ee57d6770700357db4b696b4c5250b82.cloudfront.net (CloudFront)
  < x-amz-cf-pop: ORD58-P7
  < x-amz-cf-id: qSGjLnZJNDjUkUGU2Wl297s6eezPSFs5UEF58H_hceHj9JokJkfB3A==
  <
  * Connection #0 to host hooks.treece.-dev.io left intact
  {"error":"Received malformed JSON payload."}
  ```

- Cuando tu desencadenador de webhook es invocado [sincrónicamente](#integraciones-sincronas-y-asincronas) y se detiene porque se produce un error, tu solicitud recibirá una respuesta HTTP 400 con el error que se produjo.

  ```txt title="Error en la ejecución síncrona"
  curl 'https://hooks.treece.-dev.io/trigger/example==' -v

  ...

  * We are completely uploaded and fine
  * Connection state changed (MAX_CONCURRENT_STREAMS == 128)!
  < HTTP/2 400
  < content-type: application/json
  < content-length: 55
  < date: Wed, 28 Sep 2022 19:53:33 GMT
  < x-amzn-requestid: 8e46051e-2783-4e25-b95d-35ee323ce523
  < access-control-allow-headers: Accept,CloudFront-Forwarded-Proto,CloudFront-Is-Desktop-Viewer,CloudFront-Is-Mobile-Viewer,CloudFront-Is-SmartTV-Viewer,CloudFront-Is-Tablet-Viewer,CloudFront-Viewer-ASN,CloudFront-Viewer-Country,content-type,Host,User-Agent,Via,X-Amz-Cf-Id,X-Amzn-Trace-Id,X-Forwarded-For,X-Forwarded-Port,X-Forwarded-Proto
  < x-amz-apigw-id: ZL7paEZjiYcFU4A=
  < -executionid: SW5zdGFuY2VFeGVjdXRpb25SZXN1bHQ6NTM5ZGE0YjItNDViMC00MDQxLTg3MTgtMzFhZDkwMDg1Y2Iw
  < access-control-allow-methods: POST
  < x-amzn-trace-id: Root=1-6334a63c-0d58198b7c2e26d11f4331f3;Sampled=1
  < x-cache: Error from cloudfront
  < via: 1.1 26c731836eb716e46fe9852a7aaeb508.cloudfront.net (CloudFront)
  < x-amz-cf-pop: ORD58-P7
  < x-amz-cf-id: ZKCbTC07GI90gLLyeRNmGaHub0gpULRK45_GZ7d7uGM3njGFYKaPkw==
  <
  * Connection #0 to host hooks.treece.-dev.io left intact
  {"error":"The widget requested is not in the database"}
  ```

#### HTTP 429 Demasiadas peticiones / Limitación de velocidad

Una URL de punto final de webhook puede invocarse hasta 50 veces por segundo.
Si se recibe una solicitud para una URL de endpoint que ya ha recibido 50 solicitudes en el último segundo, la solicitud recibirá una respuesta 429 de "demasiadas solicitudes".

```txt title="Tarifa de solicitud limitada"
$ curl 'https://hooks..io/trigger/example==' -v

...

< HTTP/2 429
< content-type: application/json
< content-length: 200
< date: Wed, 28 Sep 2022 19:36:55 GMT
< x-amzn-requestid: f53fbf8c-9ce6-4c4a-80a6-84edbc29fdeb
< x-amz-apigw-id: ZL5NtH82CYcFbFg=
< x-amzn-trace-id: Root=1-6334a257-1ca7ad23574a8c3255b24776;Sampled=1
< x-cache: Error from cloudfront
< via: 1.1 a044221a7cde0fa9b5dc69d5ceb4439a.cloudfront.net (CloudFront)
< x-amz-cf-pop: ORD58-P7
< x-amz-cf-id: BoOs_sbk7gB-t16ZCR4uVtD8NcPnmD40rGUPwgaouVe2hiHu60Rcjw==
<
* Connection #0 to host hooks..io left intact
{"error":"Endpoint with id: example== has exceeded maximum allowed throughput of 50 requests/second. Please throttle your requests."}
```

### Configuración del punto final Webhook

Los desencadenadores Webhook pueden configurarse para la integración de tres maneras:

- Específicos de instancia y de flujo**: Cada flujo en cada instancia obtiene su propio punto final único. Esta es la configuración por defecto.
- Específico de instancia**: Cada instancia obtiene un punto final único, y la integración determina qué flujo ejecutar en función de los datos de cabecera o de carga útil.
- Compartido**: Todas las instancias de integración de los clientes comparten un punto final. Los datos de la cabecera o de la carga útil determinan qué cliente y qué flujo deben ejecutarse.

Para obtener información sobre la configuración y solución de problemas de los puntos finales de webhook, consulta nuestro artículo [Configuración de puntos finales](endpoint-configuration.mdx).


### Envío de datos a desencadenantes webhook

Un webhook analiza datos de las siguientes fuentes:

- El **cuerpo de la solicitud** - los datos JSON (u otros) que se envían al webhook como un [cuerpo de solicitud HTTP](https://developer.mozilla.org/es/docs/Web/HTTP/Messages#body).
- Las **cabeceras de la solicitud** - las [cabeceras HTTP](https://developer.mozilla.org/es/docs/Web/HTTP/Messages#headers).
- La **ruta de URL** - la [ruta al recurso](https://developer.mozilla.org/es/docs/Learn/Common_questions/What_is_a_URL#path_to_resource) que sigue la URL del webhook de integración.
- Los **parámetros de URL** - los [parámetros](https://developer.mozilla.org/es/docs/Learn/Common_questions/What_is_a_URL#parameters) que siguen al `?` en una URL.


Tomemos, por ejemplo, esta invocación de `curl`:


```bash
curl \
  'https://hooks..io/trigger/EXAMPLE==/my/custom/path?param-one=ParamValueOne&param-two=ParamValueTwo' \
  --header "header-one: First header value" \
  --header "header-two: Second header value" \
  --header "Content-Type: application/json" \
  --data '{"Payload Key 1":"Payload Value 1","Do Thing?":true,"quantity":123}'
```

- The request body - `{"Payload Key 1":"Payload Value 1","Do Thing?":true,"quantity":123}` - is parsed (if JSON) and is accessible to the integration by referencing the trigger's `results.body.data.KEY-NAME`. Non-JSON payloads (like XML, images, etc) are accessible through `results.rawBody` and can be parsed in subsequent steps that handle that type of data.
- The request headers are accessible through the trigger's `results.headers.HEADER-NAME`.
- The url path - `my/custom/path` - is accessible through the trigger's `results.pathFragment`. You can pass that data into the built-in [split string](components/text-manipulation.mdx#split-string) action and split on the `/` character to split the URL path into an array `['my','custom','path']`.
- The url parameters - `?param-one=ParamValueOne&param-two=ParamValueTwo` are parsed and accessible through the trigger's `results.queryParameters.PARAMETER-NAME`.

<Screenshot
  filename="integrations/sending-data-to-webhook-triggers.png"
  alt="Screenshot of Sending Data to Webhook Triggers"
  maxWidth="600px"
/>

### Posting binary data with webhook triggers

If you have binary data (like an image or PDF) that you would like to post as part of your webhook invocation, you can pass that binary data in as part of your request.
For example, if you have an image, `my-image.png`, you could invoke a test of an integration with:

```bash
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --request POST \
  --header 'Content-Type: image/png' \
  --data-binary '@/path/to/my-image.png'
```

The binary file can be accessed by subsequent steps by referencing `integrationTrigger.results.body.data`.

### Posting multipart data with webhook triggers

It's useful to be able to post a combination of binary and text data to a webhook.
For example, you might want to post information about a person, as well as an avatar image of the person, to be processed by an integration.
To do that, use a content type of `multipart/form-data` with your webhook invocation:

```bash
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --request POST \
  --header "Content-Type: multipart/form-data" \
  --form person='{"firstname":"Taylor","lastname":"Reece"};type=application/json' \
  --form photo=@taylor.png
```

The first name in this example is accessible by referencing the trigger's `results.body.data.person.data.firstname`, and the avatar image is accessible by referencing `results.body.data.photo`:

<Screenshot
  filename="integrations/webhook-multipart-payload.png"
  maxWidth="600px"
  alt="Post multipart data with webhook triggers in  app"
/>

### Accessing webhook URLs in an integration

An integration is aware of its own webhook URLs, and those URLs are accessible by referencing the trigger's `results.webhookUrls` object:

<Screenshot
  filename="integrations/webhook-urls-payload.png"
  maxWidth="650px"
  alt="Access webhook URLS for integration in  app"
/>

This comes in handy if you need to configure a third-party service to send data to your webhooks.
A common pattern is for one [flow](building-integrations.mdx#flows-in-integrations) of your integration to be run when an instance is deployed using a [deploy trigger](#deploy-trigger).
That deploy-time flow can set up webhooks in a third-party app by referencing its trigger's `results.webhookUrls` values.
Then, the third-party app will invoke the other flows of the integration when it needs to.

If you use [shared endpoint configuration](endpoint-configuration.mdx), the shared endpoint URL is accessible from `results.invokeUrl`.

If you set up [API keys](endpoint-configuration.mdx/#securing-endpoints-with-api-keys) for your deployed instances, you can access `results.webhookApiKeys` similarly.
An instance's flow can have multiple API keys assigned to it, so each `results.webhookApiKeys.MY FLOW NAME` is an array.
You will likely reference the first API key, `results.webhookApiKeys.MY FLOW NAME.0`.

## Validating webhook payloads with HMAC

**Hash-Based Message Authentication Code** (or HMAC) is an authentication mechanism often used by webhook providers to verify that a webhook message is legitimate.
It helps to ensure that messages sent to a webhook endpoint originated from a particular third-party, and not from some bad actor on the internet.

### How does HMAC work?

HMAC implementations can differ slightly from one another, but generally speaking when a webhook request is sent to an endpoint, the request's body is hashed using a **secret key** and [hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function).
The resulting **hash** is sent with the webhook HTTP request as an HTTP header.

When the webhook endpoint receives the HTTP request, it also generates a hash using same secret key and hash function.
If the hash the receiver generates matches the hash that the sender sent, the webhook request is processed.
If they don't match, the request is rejected.

In order to spoof a webhook request, someone would need to know the secret key that only the sender and receiver know.
Without the secret key (even if a bad actor intercepted the webhook request), it'd be [nearly impossible](https://stackoverflow.com/questions/44472974/how-long-time-would-it-take-to-decrypt-a-sha256-hash) for a bad actor to reverse engineer the hash and send spoofed requests to a webhook endpoint.

### Generating an HMAC hash

You can configure your app to compute HMAC hashes and send them alongside your webhook requests.
To generate a hash, you need three things:

1. A request's **body** to hash.
   The body can be any format (JSON, XML, CSV, etc).
   For our example, let's say we have a JSON message that reads `{"item":"widget","quantity":5,"customer":"abc-123"}`.
1. A **secret key** that only the third-party and knows.
   For our example, we'll generate a random UUID string - `"AC49CB66-511F-4085-9119-360B1B142F4B"`
1. A **hash function** to use (like MD5, SHA1, etc.).
   The industry standard (which APIs like Dropbox, Shopify, Slack, etc. all use) is `SHA256` - we'll use that for our example, too.

Next, reach for an HMAC library for the language that your app is written in (most modern languages have an HMAC or crypto library).
Here's a few examples in a variety of languages:

<Tabs groupId="hmac-examples">
<TabItem value="python" label="Python" default>

```python title="HMAC example written in Python3"
import hmac
import hashlib

secret = bytes("AC49CB66-511F-4085-9119-360B1B142F4B", "UTF-8")
message = '{"item":"widget","quantity":5,"customer":"abc-123"}'.encode();

hash = hmac.new(secret, message, hashlib.sha256)

print(hash.digest().hex()) # dc838d5b2ee53f55b5bcd77271505f52cd4c6c5123a867d9088fb70ac580f5bf
```

</TabItem>
<TabItem value="nodejs" label="NodeJS">

```javascript title="HMAC example written in NodeJS"
const { createHmac } = require("crypto");

const secret = "AC49CB66-511F-4085-9119-360B1B142F4B";
const message = '{"item":"widget","quantity":5,"customer":"abc-123"}';

const hash = createHmac("sha256", secret).update(message, "utf-8");

console.log(hash.digest("hex")); // dc838d5b2ee53f55b5bcd77271505f52cd4c6c5123a867d9088fb70ac580f5bf
```

</TabItem>
<TabItem value="php" label="PHP">

```php title="HMAC example written in PHP"
<?php
  $message   = '{"item":"widget","quantity":5,"customer":"abc-123"}';
  $secret    = 'AC49CB66-511F-4085-9119-360B1B142F4B';

  $hash = hash_hmac('sha256', $message, $secret);

  echo ($hash); // dc838d5b2ee53f55b5bcd77271505f52cd4c6c5123a867d9088fb70ac580f5bf
?>
```

</TabItem>
<TabItem value="go" label="Go">

```go title="HMAC example written in Go"
package main

import (
  "crypto/hmac"
  "crypto/sha256"
  "encoding/hex"
  "fmt"
)

func main() {
  secret := []byte("AC49CB66-511F-4085-9119-360B1B142F4B")
  message := []byte("{\"item\":\"widget\",\"quantity\":5,\"customer\":\"abc-123\"}")

  h := hmac.New(sha256.New, secret)
  h.Write(message)
  hash := hex.EncodeToString(h.Sum(nil))

  fmt.Println(hash) // dc838d5b2ee53f55b5bcd77271505f52cd4c6c5123a867d9088fb70ac580f5bf
}
```

</TabItem>
</Tabs>

Regardless of which language you use to generate the HMAC hash, you get the same result for our example - `dc838d5b2ee53f55b5bcd77271505f52cd4c6c5123a867d9088fb70ac580f5bf`.
You can then pass the hash as an HTTP header to our webhook URL.

```bash
curl https://hooks..io/example-uuid \
  --request POST \
  --header "my-hmac-header: dc838d5b2ee53f55b5bcd77271505f52cd4c6c5123a867d9088fb70ac580f5bf" \
  --header "content-type: application/json" \
  --data '{"item":"widget","quantity":5,"customer":"abc-123"}'
```

**Can I include the HMAC hash in the body instead?**
That's a common question, and the answer is a resounding **no**.
By adding the HMAC hash to the body, you change the body... so a different body hash is computed... which requires you to change the body... (GOTO 10).
An HMAC hash should be sent via a header.

### Validating HMAC hashes in a trigger

If your HMAC hash is generated from the HTTP payload's body, the secret signing key is a string, and the hash is included as a header, you can use the built-in [HMAC Webhook Trigger](components/hash.mdx#hmac-webhook-trigger) to validate payloads.
Configure the trigger by setting the name of the header that contains the HMAC hash (e.g. `x-hmac-sha256`), the hashing function you used (e.g. `sha256`), and the secret key you used, and the trigger will accept payloads that are properly signed, and throw an error when payloads are not signed correctly.
The trigger otherwise operates like the standard built-in webhook trigger.

If the app you're integrating with deviates from standard HMAC signing practices, or if you need to respond to webhook requests with dynamic responses, you can build your own custom trigger that handles HMAC validation.
Slack, for example, includes an additional parameter (a timestamp) in its HMAC computation, and expects a custom response from the webhook endpoint.
You can read about how the Slack webhook trigger works in [this quickstart](quickstarts/custom-trigger-with-hmac.mdx).

## Instance deploy trigger

An integration flow can be configured to be run when an instance of the integration is [deployed](instances.mdx#deploying-instances).
To do that, click your trigger and then click **CHANGE TRIGGER**.
Choose to replace your trigger with a [Management Triggers - Instance Deploy](components/management-triggers.mdx#instance-deploy) trigger.
This will cause your current flow to run whenever the integration is deployed as an instance to a customer.

This is handy if your integration needs to complete a series of tasks when its deployed.
For example, your integration might need to configure a third-party app to send data to the other flows' webhooks.
Or, your integration might need to enable features in a third-party app or create a series of directories in a file share before the integration is invoked.

If there are tasks that need to occur when an instance is deployed, set up those tasks as a flow and configure the trigger to run at deploy time.

**For More Information**:
[Multiple Flows with a Deploy Trigger](quickstarts/building-an-integration-with-multiple-flows.mdx)

## Instance remove trigger

The opposite of an [instance deploy trigger](#instance-deploy-trigger) is an [instance remove](components/management-triggers.mdx#instance-remove) trigger.
Flows with this trigger run when an instance is removed (deleted), and can be used to clean up webhooks and other configuration that an instance deploy trigger created.

## Custom triggers

You can [build your own triggers](custom-components/writing-custom-components.mdx#writing-triggers) as part of a custom component.
This is helpful if you need to generate dynamic responses to webhook requests, or do HMAC or other payload validation before your integration runs.

## Synchronous and asynchronous integrations

Integrations are configured by default to run **asynchronously**.
That means that whenever an integration is invoked by trigger webhook URL, the integration begins to run and the system that invoked the integration can go on to complete other work.
This is the most common case for integrations - you want to start up an instance when some certain event occurs, but you don't want to wait around while the instance runs.

Sometimes, though, it's handy for an application to get information back from the instance that was invoked.
For example, you might want your proprietary software to wait until an instance runs to completion before completing other work.
In that case, you can choose to run your integration **synchronously**.
Then, when your software makes a call to the instance's webhook trigger URL the HTTP request is held open until the instance run is complete.

<Vimeo title="How to Run Integrations Synchronously" video="505768225" />

When you choose to run your integrations **synchronously**, the HTTP request that invokes an instance returns a _redirect_ to a URL containing the output results of the final step of the integration.
For example, if the final step of your integration pulls down JSON from https://jsonplaceholder.typicode.com/users/1, you will see this when you invoke the integration synchronously:

```bash
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --data '{}' \
  --header "Content-Type: application/json" \
  --header "-synchronous: true" \
  --location

{"id":1,"name":"Leanne Graham","username":"Bret","email":"Sincere@april.biz","address":{"street":"Kulas Light","suite":"Apt. 556","city":"Gwenborough","zipcode":"92998-3874","geo":{"lat":"-37.3159","lng":"81.1496"}},"phone":"1-770-736-8031 x56442","website":"hildegard.org","company":{"name":"Romaguera-Crona","catchPhrase":"Multi-layered client-server neural-net","bs":"harness real-time e-markets"}}
```

You can toggle if your integration is synchronous or asynchronous by clicking the trigger and selecting a **Response Type**.

You can also pass in a header, `-synchronous` with a webhook invocation to instruct your instance to run synchronously or asynchronously:

```bash
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --header "-synchronous: false" \
  --request POST
```

#### Synchronous invocations and redirects

When you invoke an instance synchronously, the output of the final step of your integration is written to Amazon S3.
The HTTP request that invoked the integration execution then receives a response that redirects them to the file in Amazon S3.
We do this because Amazon's API Gateway has a 10MB limit on HTTP responses, and step results may exceed 10MB - S3 has no such size limit.

Because of this redirection, you should make sure that your request library is configured to follow HTTP status code 303 redirects.
For `curl`, for example, include a `-L / --location` flag so it follows redirects.

If the party initiating the instance execution request does not support following redirects, they can pass an optional header, `-prefer-direct-sync-response: true` with their request to skip the redirect to S3, and return the response directly.
_Note_: This only works for step results less than 5MB in size, and your last step's results must be text-like (i.e. JSON, XML, plain text, etc - not a binary file).
If your final step's output is greater than 5MB, they'll be redirected to S3.
This works well if your final step's result is text.

```bash title="Skip the redirect to Amazon S3"
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --header "-synchronous: true" \
  --header "-prefer-direct-sync-response: true" \
  --request POST \
  --data "{}"
```

If the third-party also doesn't support custom headers, you can append `-prefer-direct-sync-response=true` as a search parameter:

```bash title="Skip the redirect to Amazon S3 with a search parameter"
curl 'https://hooks..io/trigger/EXAMPLE==?-prefer-direct-sync-response=true'
```

:::tip Response content type
You can control the `content-type` of the response by adding a `contentType` property to your last step's result.
For example,

```typescript
const returnData = `<note>
    <to>Tove</to>
    <from>Jani</from>
    <heading>Reminder</heading>
    <body>Don't forget me this weekend!</body>
</note>`;

return {
  data: returnData,
  contentType: "application/xml",
};
```

:::

### HTTP status codes for synchronous integrations

When an instance is configured to run synchronously or is invoked synchronously with the `-synchronous` header, the HTTP response returns a status code `200 - OK` by default.
It's sometimes useful, though, to return other HTTP status codes.
For example, if a client submits wrongly formatted data to be processed by an instance, it might be helpful to return a `406 - Not Acceptible` or `415 - Unsupported Media Type`.

To accomplish this, you can configure the final step of your integration to return a different status code.
Most commonly, you can add a [Stop Execution](components/stop-execution.mdx) step to the end of your integration, and specify an HTTP response that it should return.

<Screenshot
  filename="integrations/stop-execution-status-code.png"
  alt="Configure HTTP status codes for synchronous integrations in  app"
/>

```bash
$ curl 'https://hooks..io/trigger/EXAMPLE==' \
   --verbose \
   --location \
   --header "-synchronous: true"

* TCP_NODELAY set
* Connected to hooks..io (13.227.37.2) port 443 (#0)

...

< HTTP/2 415
```

If you would like to return HTTP status codes from a custom component at the end of your integration instead, return an object with a `statusCode` attribute instead of a `data` attribute:

```javascript
return { statusCode: 415 };
```

### Synchronous call limitations

#### Response body and status code limitations

When an integration is invoked synchronously, the integration redirects the caller to a URL containing the output results of the final step of the integration.
If the final step of the integration is a [Stop Execution](components/stop-execution.mdx) action, or any custom component action that returns a `statusCode`, the redirect does not occur and the caller receives a `null` response body instead.

#### API gateway size and time limitations

AWS API Gateway times out requests after 29 seconds, and our maximum response size is 500MB.
So, to get a response from an instance that is invoked synchronously, please ensure that your integration runs in under 29 seconds and produces a final step payload of less that 500MB.

If your integration regularly takes over 29 seconds to run, or produces large responses, we recommend that you run your integrations asynchronously instead.
When you invoke an integration asynchronously you receive an `executionId`:

```bash
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --data '{}' \
  --header "Content-Type: application/json"

{"executionId":"SW5zdGFuY2VFeGVjdXRpb25SZXN1bHQ6OTdiNWQxYmEtZGUyZi00ZDY4LWIyMTgtMDFlZGMwMTQxNTM5"}
```

That execution ID can be exchanged later with the API for logs and step results using the [executionResult](api/schema/query/executionResult.mdx) GraphQL mutation.

## Ensuring webhook ordering with a FIFO queue

's integration runner is designed to process requests in parallel.
If you invoke an integration with multiple requests in quick succession, the runner will scale and process all of the requests at the same time.

If you have a workflow that requires requests to be processed in a specific order, or a workflow that requires you to process only one record at a time, you'll need to take some extra steps to ensure that the requests are processed sequentially.
Check out our [FIFO Queue](quickstarts/fifo-queue.mdx) tutorial for more information.
