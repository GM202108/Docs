---
id: writing-custom-components
title: Creación de componentes personalizados
description: permite a los usuarios desarrolladores escribir conectores API personalizados y otros componentes para sus integraciones.
---

import Screenshot from "@site/src/components/screenshot";
import Vimeo from "@site/src/components/vimeo";
import SlugifyBox from "@site/src/components/slugify-box";

Es extensible y permite a los desarrolladores crear sus propios componentes personalizados.
Los componentes desarrollados por los usuarios son de propiedad exclusiva de su [organización](organization.mdx) y son privados.

[Fragmento de código del componente de muestra](https://github.com/-io/examples/tree/main/components) se hace referencia en toda esta página.

Para obtener un componente de muestra que envuelve una API basada en HTTP, consulta nuestra guía rápida sobre [Cómo envolver una API en un componente](quickstarts/wrapping-an-api-in-a-component.mdx).

## Biblioteca de componentes personalizados

[![Versión de NPM de Spectral](https://badge.fury.io/js/@-io%2Fspectral.svg)](https://www.npmjs.com/package/@-io/spectral)

proporciona un paquete NodeJS, [@-io/spectral](https://www.npmjs.com/package/@-io/spectral), que ofrece tipos TypeScript y algunas funciones de utilidad.
El código fuente de Spectral está disponible en [GitHub](https://github.com/-io/spectral).

Para obtener información sobre las funciones de utilidad y los tipos de Spectral, consulta nuestra documentación sobre [biblioteca de componentes personalizados](spectral/custom-component-library.mdx).

**Compatibilidad con versiones de NodeJS**: Aunque muchas versiones de NodeJS pueden funcionar para el desarrollo de componentes, recomendamos utilizar la última versión LTS (soporte a largo plazo) de NodeJS.
Puedes encontrar la última versión LTS en la [página de descargas de NodeJS](https://nodejs.org/en/download/).

## Inicializar un nuevo componente

Para inicializar un nuevo proyecto, ejecuta `prism components:init {{ NOMBRE DEL COMPONENTE }}`.
Si no tienes instalada la herramienta de línea de comandos de 's, `prism`, tómate un momento para revisar la [página de descripción general de Prism](cli/cli-usage.mdx).


```bash
prism components:init format-name
```

El nombre de tu componente debe estar compuesto por caracteres alfanuméricos, guiones y guiones bajos, y debe comenzar y terminar con caracteres alfanuméricos.
Se te solicitará que respondas algunas preguntas, como proporcionar una descripción para tu componente y determinar qué tipo de autorización de conexión se debe plantillar (puedes editar esto más tarde).


Esto creará una estructura de directorios como la siguiente:

```
format-name
├── assets
│   └── icon.png
├── jest.config.js
├── package.json
├── src
│   ├── actions.ts
│   ├── client.ts
│   ├── connections.ts
│   ├── index.test.ts
│   ├── index.ts
│   └── triggers.ts
├── tsconfig.json
└── webpack.config.js
```

- `assets/icon.png` es el icono que se mostrará junto a tu componente. Los archivos PNG cuadrados y transparentes, con al menos 128 x 128 píxeles, son los más adecuados y serán escalados adecuadamente por la aplicación web.

- `jest.config.js` contiene la configuración para el marco de pruebas [Jest](https://jestjs.io/).

- `package.json` es un archivo de definición estándar del paquete de Node.

- `src/actions.ts` contiene las acciones de tu componente. Esto puede dividirse en archivos distintos a medida que tu código crece.

- `src/client.ts` contiene un "cliente" compartido. Esto es útil para acciones que comparten un mecanismo para conectarse a una API. El "cliente" probablemente será un cliente HTTP autenticado configurado para hacer solicitudes a un endpoint específico.

- `src/connections.ts` contiene las conexiones que tu componente utiliza para autenticarse con APIs de terceros.

- `src/index.test.ts` contiene pruebas para las acciones del componente. Consulta [Pruebas unitarias de componentes personalizados](quickstarts/unit-testing-custom-components.mdx).

- `src/index.ts` contiene la definición de tu componente.

- `src/triggers.ts` contiene disparadores personalizados.

- `tsconfig.json` contiene la configuración para [TypeScript](https://www.typescriptlang.org/).

- `webpack.config.js` contiene la configuración para [Webpack](https://webpack.js.org/).

### Componentes personalizados a partir de WSDLs o especificaciones OpenAPI

Las aplicaciones y servicios de terceros a menudo proporcionan APIs con cientos de puntos finales RESTful. Sería tedioso escribir manualmente acciones para cada punto final individual. Afortunadamente, muchas empresas también proporcionan una especificación de API, comúnmente un archivo [Web Service Definition Language (WSDL)](https://www.w3.org/TR/2001/NOTE-wsdl-20010315) o una especificación [OpenAPI (Swagger)](https://swagger.io/specification/).


Puedes generar un componente personalizado a partir de un archivo WSDL con `prism` pasando la bandera `--wsdl-path` al subcomando `components:init`:


```bash
prism components:init myThirdPartyComponent --wsdl-path ./thirdPartySpec.wsdl
```

Puedes generar un componente personalizado a partir de una definición OpenAPI (puedes usar un archivo YAML o JSON, ambos funcionan bien) con `prism` al pasar la bandera `--open-api-path` al subcomando `components:init`:


```bash
prism components:init myThirdPartyComponent --open-api-path ./third-party-openapi-spec.json
```

El código del componente personalizado que se genera puede requerir algunos ajustes; algunas APIs tienen encabezados requeridos no documentados o esquemas de autenticación irregulares (por lo que es posible que debas modificar `src/client.ts` o `src/connection.ts`).
Pero esto te proporciona un excelente punto de partida al construir un componente personalizado para una aplicación de terceros.

## Escribir acciones

Un componente está compuesto por cero, una o muchas [acciones](components.mdx#component-actions).
Por ejemplo, el [componente HTTP](components/http.mdx) contiene acciones como [GET](components/http.mdx#httpget) (`httpGet`), [POST](components/http.mdx#post-request) (`httpPost`), etc.


Una `action` tiene tres propiedades obligatorias y una opcional:


1. Información sobre cómo la aplicación web `display` la acción
2. Una función para `perform`
3. Una serie de campos `input`


```typescript
const myAction = action({
  display: {
    label: "Brief Description",
    description: "Descripción más larga para mostrar en la interfaz de usuario de la aplicación web",
  },
  perform: async (context, params) => {},
  inputs: { inputFieldOne, inputFieldTwo },
});
```

### Agregar entradas

Los componentes pueden tener [`entradas`](components.mdx#entradas). Cada `entrada` está compuesta por un `etiqueta` obligatoria, y `tipo` y opciones opcionales como `espacio reservado`, `predeterminado`, `comentarios`, `obligatorio` y `modelo`.


Considere este ejemplo de entrada:

```typescript
const middleName = input({
  label: "Middle Name",
  placeholder: "Middle name of a person",
  type: "string",
  required: false,
  default: "",
  comments: "Dejar en blanco si el usuario no tiene segundo nombre",
});
```

Esto contribuye a un mensaje de entrada que se parece a esto:

<Screenshot
  filename="custom-components/writing-custom-components/inputs.png"
  alt="Paso Configurar - Formatear correctamente el nombre en la aplicación"
/>

Ten en cuenta dónde apareció el texto de `label` y `placeholder` en la aplicación web, y observa que Nombre y Apellido son obligatorios, indicados con un `*`, pero el Segundo Nombre no lo es.


### Limpiar las entradas

Una entrada de una acción puede ser cualquier cosa: un número, una cadena, un booleano, un búfer de JavaScript, un objeto complejo con muchas propiedades, etc.
Si reutilizas una entrada para varias acciones, es útil realizar algún procesamiento previo y conversión de tipo en la entrada.
Aquí es donde entra en juego una función de `limpieza` en una entrada.

Por ejemplo, supongamos que esperas que una entrada sea un número.
Sin embargo, las entradas por defecto se presentan a las funciones `perform` como cadenas.
Puedes aprovechar la función de utilidad [`util.types.toNumber()`](spectral/modules/_util_.md/#const-tonumber) y la propiedad `clean` para asegurarte de que la entrada se presente a la función `perform` como un número:


```typescript title="Asegúrese de que la entrada es un número"
const serverPortInput = input({
  label: "Server Port",
  placeholder: "El puerto del servidor API",
  comments: "Busque el número después de los dos puntos (my-server.com:3000)"
  type: "string",
  default: "3000",
  required: true,
  // highlight-next-line
  clean: (value) => util.types.toNumber(value),
});
```

También puedes agregar validación al input. Por ejemplo, si deseas validar que el input sea una dirección IP IPv4, puedes construir una función `clean` más compleja:


```typescript {1-8,16} title="Validar que una entrada es una dirección IP"
const validateIpAddress = (value: unknown) => {
  const ipAddressRegex =
    /^(?:(?:2(?:[0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(?:(?:2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9]))$/;
  const inputValue = util.types.toString(value);
  if (!ipAddressRegex.test(inputValue)) {
    throw new Error(`The value "${inputValue}" is not a valid IP address`);
  }
  return inputValue;
};

const ipAddressInput = input({
  label: "IP Address",
  placeholder: "Server IP Address",
  type: "string",
  default: "192.168.1.1",
  required: true,
  clean: validateIpAddress,
});
```

### Tipos de entrada de acción

Un input puede tener varios tipos, lo cual afecta cómo se muestra el input en la aplicación web:

- **string** permitirá a los usuarios ingresar o hacer referencia a una cadena de caracteres.

  <Screenshot
    filename="custom-components/writing-custom-components/input-types/string.png"
    maxWidth="500px"
    alt="Entrada de cadenas en la aplicación"
  />

- **password** permitirá a los usuarios ingresar o hacer referencia a una cadena de caracteres, y la cadena se ocultará en la interfaz de usuario.

  <Screenshot
    filename="custom-components/writing-custom-components/input-types/password.png"
    maxWidth="500px"
    alt="Introducción de contraseña en la aplicación"
  />

- **text** es similar a **string**, pero permite la entrada en varias líneas.

  <Screenshot
    filename="custom-components/writing-custom-components/input-types/text.png"
    maxWidth="500px"
    alt="Introducción de texto en la aplicación"
  />

- **boolean** permite a los usuarios ingresar uno de dos valores: true o false.

  <Screenshot
    filename="custom-components/writing-custom-components/input-types/boolean.png"
    maxWidth="350px"
    alt="Entrada booleana en la aplicación"
  />

- **code** abre un editor de código para que los usuarios puedan ingresar XML, HTML, JSON, etc.
  La resaltación de sintaxis se puede agregar a la definición de una entrada **code** y puede hacer referencia a cualquier lenguaje admitido por [PrismJS](https://prismjs.com/#supported-languages).

  (e.g. `input({ label: "My Code", type: "code", language: "json" })`)
  <Screenshot
    filename="custom-components/writing-custom-components/input-types/code.png"
    maxWidth="480px"
    alt="Editor de código en la aplicación"
  />

- **conditional** permite a los usuarios ingresar una serie de condicionales lógicos.
  Esto se utiliza principalmente en el componente [branch](components/branch.mdx).

  <Screenshot
    filename="custom-components/writing-custom-components/input-types/conditional.png"
    maxWidth="500px"
    alt="Entrada condicional en la aplicación"
  />

También puedes crear entradas de tipo **connection** para acciones.
Lee más sobre las conexiones [abajo](#agregar-acciones).

### Entradas de menú desplegable

En lugar de permitir a los creadores de integraciones ingresar valores para una entrada, es posible que desees que los usuarios elijan un valor de una lista de posibles valores.
Puedes lograrlo convirtiendo tu entrada en un menú desplegable.


<Screenshot
  filename="custom-components/writing-custom-components/dropdown-input.png"
  maxWidth="500px"
  alt="Menú desplegable en la aplicación"
/>

Para crear una entrada con un menú desplegable, agrega una propiedad `model` a tu entrada:


```ts
export const acmeEnvironment = input({
  label: "Acme Inc Environment to Use",
  placeholder: "ACME Environment",
  type: "string",
  required: true,
  model: [
    {
      label: "Production",
      value: "https://api.acme.com/",
    },
    {
      label: "Staging",
      value: "https://staging.acme.com/api",
    },
    {
      label: "Sandbox",
      value: "https://sandbox.acme.com/api",
    },
  ],
});
```

La propiedad `model` debe ser un array de objetos, donde cada objeto contiene una `label` y un `value`.
La `label` se muestra en el menú desplegable.
El `value` se pasa como el valor de la entrada al componente personalizado.

### Entradas de colección

La mayoría de las entradas representan cadenas individuales.
Una entrada de **colección**, por otro lado, representa un array de valores o pares clave-valor.
Las colecciones son útiles cuando no sabes cuántos elementos podría necesitar un usuario del componente.

#### Colección de lista de valores

Por ejemplo, tu componente podría requerir un array de registros para realizar una consulta, pero es posible que no sepas cuántos IDs de registros ingresará un usuario del componente.
Puedes crear una colección `valuelist` de la siguiente manera:


```typescript {4} title="Value List Collection Example"
const recordIdsInputField = input({
  label: "Record ID",
  type: "string",
  collection: "valuelist",
  required: true,
});
```

La interfaz de usuario correspondiente en el diseñador de integración solicitará al usuario el número de ID de registro que desee introducir:

<Screenshot
  filename="custom-components/writing-custom-components/input-types/value-list-collection.png"
  maxWidth="500px"
  alt="Colección de listas de valores en la aplicación"
/>

Cuando la entrada se recibe en la [función perform](#writing-perform-functions) de una acción, la entrada es un `string[]`.

#### Colección de lista de clave-valor

Si deseas que los usuarios ingresen una serie de pares clave-valor como entrada, puedes usar una colección `keyvaluelist`.
La entrada de _Header_ en las acciones del [componente HTTP](components/http.mdx#get-request) es un ejemplo de una colección `keyvaluelist` y se define en el código de la siguiente manera:


```typescript {4} title="Key Value List Input"
export const headersInputField = input({
  label: "Header",
  type: "string",
  collection: "keyvaluelist",
  required: false,
  comments: "A list of headers to send with the request.",
  example: "User-Agent: curl/7.64.1",
});
```

El campo "Header", entonces, aparecerá así en el diseñador de integraciones:


<Screenshot
  filename="custom-components/writing-custom-components/input-types/key-value-list-collection.png"
  maxWidth="500px"
  alt="Colección de listas de valores clave en la aplicación"
/>

Cuando la entrada es recibida por la función [perform](#writing-perform-functions) de una acción, la entrada es un array de objetos en la forma:


```typescript
[
  {
    key: "foo",
    value: "bar",
  },
  {
    key: "baz",
    value: 5,
  },
];
```

Si deseas convertir la entrada a un objeto de pares clave-valor, puedes utilizar la función integrada de Spectral, [keyValPairListToObject](spectral/modules/_util_.md#const-keyvalpairlisttoobject):


```typescript
import { util } from "@-io/spectral";
const myObject = util.types.keyValPairListToObject(myInput);
// { foo: "bar", baz: 5 }
```

### Escribiendo funciones `perform`

Cada acción contiene una función `perform`, que es una función asíncrona con dos parámetros que pueden o no tener un valor de retorno. En este ejemplo, `firstName`, `middleName` y `lastName` son parámetros de entrada para esta función `perform`:


```typescript {7-15}
export const properFormatName = action({
  display: {
    label: "Properly Format Name",
    description: "Properly format a person's name (Last, First M.)",
  },
  perform: async (context, params) => {
    if (params.middleName) {
      return {
        data: `${params.lastName}, ${params.firstName} ${params.middleName[0]}.`,
      };
    } else {
      return { data: `${params.lastName}, ${params.firstName}` };
    }
  },
  inputs: { firstName, middleName, lastName },
});
```

### Parámetros de la función `perform`

La función `perform` toma dos parámetros, `context` y `params`, que pueden desestructurarse en sus propiedades respectivas:

```typescript
perform: async (context, params) => {},
// or
perform: async (
  { logger },
  { paramName1, paramName2, ... }
) => {},
```

### Parámetro `context`

El parámetro `context` es un objeto que contiene los siguientes atributos:

- `logger` te permite escribir líneas de registro.
- `instanceState`, `crossFlowState`, `integrationState` y `executionState` te brindan acceso a [estado persistente](custom-components/writing-custom-components.mdx#execution-instance-and-cross-flow-state).
- `stepId` es el ID del paso actual que se está ejecutando.
- `executionId` es el ID de la ejecución actual.
- `webhookUrls` contiene las URL de las instancias en ejecución de flujos hermanos.
- `webhookApiKeys` contiene las claves API de las instancias en ejecución de flujos hermanos.
- `invokeUrl` fue la URL utilizada para invocar la integración.
- `customer` es un objeto que contiene un `id`, `name`, y `externalId` del cliente al que se asigna la instancia.
- `user` es un objeto que contiene un `id`, `name`, `email` (su ID) y `externalId` del usuario del cliente cuya configuración a nivel de usuario se utilizó para esta ejecución.
  Esto solo se aplica a las instancias con [Configuración a Nivel de Usuario](user-level-configuration.mdx).
- `integration` es un objeto que contiene un `id`, `name`, y `versionSequenceId` de la integración de la cual se creó la instancia.
- `instance` es un objeto que contiene un `id` y `name` de la instancia en ejecución.
- `flow` es un objeto que contiene el `id` y `name` del flujo en ejecución.

#### ID del Paso

`context.stepId` contiene el identificador único (UUID) del paso.
Se utiliza en la acción [Procesar Datos - Eliminar Duplicados](components/process-data.mdx#deduplicate) para rastrear qué elementos en un array se han visto previamente o no.
Puedes usarlo de manera similar en un componente personalizado para persistir datos específicos del paso.

#### URL de Webhook

Puedes hacer referencia a las URL de webhook de una instancia a través del objeto `context.webhookUrls`.
Esto es útil al escribir acciones para configurar y eliminar webhooks en una aplicación de terceros.


```typescript
perform: async (context, params) => {
  const inventoryUrl = context.webhookUrls["My Inventory Flow"];
};
```

Puedes hacer referencia a `context.flow.name` para obtener la URL del webhook del flujo actual:


```typescript
perform: async (context, params) => {
  const myCurrentUrl = context.webhookUrls[context.flow.name];
};
```

### Objeto de registro

`context.logger` es un objeto de registro y puede ser útil para depurar componentes.


```typescript
perform: async ({ logger }, params) => {
  logger.info("Things are going great");
  logger.warn("Now less great...");
};
```

Funciones de registro disponibles en orden creciente de gravedad: `logger.debug`, `logger.info`, `logger.warn` y `logger.error`.

También puedes ejecutar `logger.metric` en un objeto, lo cual es útil cuando [transmites registros y métricas](logging.mdx#external-log-streaming) a un servicio de registro externo.

**Nota**: Las líneas de registro se truncarán después de 4096 caracteres.
Si necesitas líneas de registro más largas, considera [transmitir registros](logging.mdx#external-log-streaming) a un servicio de registro externo.


### Estado de ejecución, instancia y flujo cruzado

`context.executionState`, `context.instanceState`, `context.integrationState` y `context.crossFlowState` son almacenes de clave/valor que se pueden utilizar para almacenar pequeñas cantidades de datos para uso futuro:

- `context.executionState` almacena el estado durante la ejecución y se utiliza a menudo como acumulador para bucles.
- `context.instanceState` almacena el estado que persiste entre ejecuciones. Este estado está vinculado a un flujo específico. El flujo puede persistir datos y hacer referencia a ellos en una ejecución posterior.
  :::note _¿No debería llamarse `flowState` o algo así en lugar de `instanceState`?_
  ¡Buena pregunta! Desarrollamos el almacenamiento de estado antes de la existencia de flujos múltiples, y el nombre `instanceState` se mantuvo por razones históricas.
  :::
- `context.crossFlowState` también almacena el estado que persiste entre ejecuciones. Este estado está vinculado a la instancia, y los flujos pueden hacer referencia al estado almacenado de otros flujos.
- `context.integrationState` almacena el estado entre flujos en instancias de la misma integración. El flujo 1 del Cliente A puede compartir datos con el flujo 2 del Cliente B.

El estado se utiliza principalmente en los componentes [Persistir datos](components/persist-data.mdx) y [Procesar datos](components/process-data.mdx), pero también puedes usarlo en tus componentes personalizados.

Si, por ejemplo, una ejecución anterior del flujo guardó una clave de estado llamada `sampleKey`, puedes hacer referencia a `context.instanceState['sampleKey']` para acceder al valor de esa clave.

Para hacer lo contrario y guardar datos en el almacenamiento de estado de un flujo para ejecuciones posteriores, agrega una propiedad `instanceState` al valor de retorno de la función `perform`:


```typescript
return {
  data: "Some Data",
  instanceState: { exampleKey: "example value", anotherKey: [1, 2, 3] },
};
```

**Nota**: Para eliminar una clave del estado persistido, establece su valor en `null`:


```typescript title="Remove a key from crossFlowState"
return {
  data: "Some Data",
  crossFlowState: { exampleKey: null },
};
```

### Parámetros de entrada

El parámetro `params` es un objeto que tiene atributos para cada campo de entrada que la acción admite.
Por ejemplo, para la acción de ejecución [definida anteriormente](#writing-perform-functions), `params` tiene `params.firstName`, `params.middleName` y `params.lastName`.

`firstName`, `middleName` y `lastName` se basan en los objetos de entrada que se proporcionan a la acción como `inputs`.

:::note Nombres de propiedades abreviados
Puedes utilizar [nombres de propiedades abreviados](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer) para las entradas.
Si las variables de objeto de entrada tienen nombres diferentes, por ejemplo, si tienes un `const myFirstNameInput = input({...})`, puedes estructurar la propiedad de entrada de tu acción de la siguiente manera:


```typescript
inputs: {
  firstName: myFirstNameInput,
  middleName: myMiddleNameInput,
  lastName: myLastNameInput,
}
```

Y el objeto `params` pasado a `perform` tendrá claves `firstName`, `middleName` y `lastName`.

Para algunos desarrolladores, es preferible utilizar nombres de propiedades no abreviados para evitar [sombreado de variables](https://en.wikipedia.org/wiki/Variable_shadowing).
:::


La función está escrita con un parámetro `params` desestructurado.
Podría ser reescrito sin desestructuración.


```typescript {1-3,6}
perform: async (context, params) => {
  if (params.middleName == "") {
    return { data: `${params.lastName}, ${params.firstName}` };
  } else {
    return {
      data: `${params.lastName}, ${params.firstName} ${params.middleName[0]}.`,
    };
  }
},
```

### Coerción de tipos de entrada

Las bibliotecas de Node basadas en TypeScript a menudo tienen reglas estrictas sobre el tipo de variables que se pasan a sus funciones, pero las entradas a las funciones `perform` son de tipo `unknown` ya que no se sabe de antemano qué tipos de valores los usuarios de los componentes van a pasar.
Por ejemplo, podrías esperar que una de tus entradas sea un `number`, pero un usuario podría pasar un `string` en su lugar.
Eso obviamente es un problema, ya que `"2" + 3` es `"23"`, mientras que `2 + 3` es `5` en JavaScript.

El paquete Spectral incluye varias [funciones de utilidad](spectral/modules/_util_.md) para forzar que la entrada sea del tipo de variable que necesitas.
Mirando el ejemplo de número/cadena, supongamos que tienes una entrada, `quantity`, que necesitas convertir en un número (incluso si alguien pasa `"123.45"` como cadena), y tienes otra entrada, `itemName`, que te gustaría que sea una cadena.
Puedes usar `util.types.toNumber()` y `util.types.toString()` para asegurarte de que la entrada se haya convertido a un número y una cadena respectivamente:


```typescript
import { action, util } from "@-io/spectral";
import { someThirdPartyApiCall } from "some-example-third-party-library";

action({
  /*...*/
  perform: async (context, { quantity, itemName }) => {
    const response = await someThirdPartyApiCall({
      orderQuantity: util.types.toNumber(quantity), // Guaranteed to be a number
      orderItemName: util.types.toString(itemName), // Guaranteed to be a string
    });
    return { data: response };
  },
});
```

Si una entrada no se puede coercer al tipo que has elegido, por ejemplo, supongamos que pasas `"Hola Mundo"` a `util.toNumber()`, se lanzará un error indicando que `"Hola Mundo"` no se puede convertir en un número.

#### Escribir tus propias funciones de verificación de tipo

proporciona una variedad de funciones de verificación y coerción de tipo para tipos comunes (número, entero, cadena, booleano, etc).
Si necesitas un objeto con una forma única, puedes crear tus propias funciones de verificación y coerción de tipo para asegurarte de que las entradas que recibe tu componente personalizado tengan la forma adecuada que esperan las bibliotecas en las que confías.

Puedes importar una `interface` o `type` (o escribir uno tú mismo) y escribir una función que convierta las entradas en una forma esperada.
Por ejemplo, el SDK de SendGrid espera un objeto con esta forma:


```javascript
{
  "to": [string],
  "from": string,
  "subject": string,
  "text": string,
  "html": string
}
```

Podemos importar ese tipo definido, `MailDataRequired`, del SDK de SendGrid, y escribir una función que tome entradas y las convierta en un objeto que contenga una serie de cadenas:


```typescript
import { MailDataRequired } from "@sendgrid/mail";
import { util } from "@-io/spectral";

export const createEmailPayload = ({
  to,
  from,
  subject,
  text,
  html,
}): MailDataRequired => ({
  to: util.types
    .toString(to)
    .split(",")
    .map((recipient: string) => recipient.trim()),
  from: util.types.toString(from),
  subject: util.types.toString(from),
  text: util.types.toString(text),
  html: util.types.toString(html),
});
```

### Resultados de la Acción

Una acción puede devolver varios tipos de datos.
Para devolver una cadena simple, un número, un booleano, un array o un objeto, tu bloque de retorno puede ser así:


```typescript
// return a string:
return {
  data: "some string",
};
// return a number:
return {
  data: 123.45,
};
// return a boolean:
return {
  data: true,
};
// return an array:
return {
  data: [1, 2, 3, 4, "a", "b"],
};
// return an object:
return {
  data: {
    key1: "value1",
    key2: ["value2", 123],
  },
};
```

Esos valores se pueden usar como entradas en pasos subsecuentes haciendo referencia a los `resultados` de este paso:


<Screenshot
  filename="custom-components/writing-custom-components/step-results.png"
  maxWidth="600px"
  alt="Paso resultados de una acción en app"
/>

### Configuración de códigos de estado HTTP sincrónicos

Si invocas tus instancias de manera [sincrónica](integration-triggers.mdx#http-status-codes-for-synchronous-integrations) y deseas devolver un código de estado HTTP diferente a `200 - OK`, puedes configurar el último paso de tu integración como un componente personalizado que devuelva cualquier código de estado HTTP que desees.

Para devolver un código de estado HTTP distinto de 200, incluye un atributo `statusCode` en el objeto que devuelves desde tu componente personalizado en lugar de un atributo `data`:


```typescript
return {
  statusCode: 415,
};
```

Si este componente personalizado es el último paso de una integración, la integración devolverá un código de estado HTTP de 415 si se invoca de manera síncrona.

Nota: Cuando se invoca una integración de manera síncrona, la integración redirige al solicitante a una URL que contiene los resultados de salida del último paso de la integración.
Si el último paso de la integración es una acción de [Detener ejecución](components/stop-execution.mdx) o cualquier acción de componente personalizado que devuelva un `statusCode`, el redireccionamiento no ocurre y el solicitante recibe un cuerpo de respuesta `null` en su lugar.
No debes devolver tanto atributos `data` como `statusCode` en un componente personalizado.

### Ejemplo de cargas útiles de acciones

Como se mencionó anteriormente, las acciones devuelven resultados para que los pasos posteriores los consuman.
A menudo, es útil que el creador de la integración tenga acceso a la forma de los resultados antes de que se ejecute una prueba.
Tu acción puede proporcionar un `examplePayload` que se puede consultar antes de que los datos de prueba estén disponibles:


```typescript
{
  /* ... */
  examplePayload: {
    data: {
      username: "john.doe",
      name: {
        first: "John",
        last: "Doe",
      },
      age: 20,
    },
  },
}
```

En el diseñador de integraciones, este ejemplo de carga útil se puede referenciar como una entrada.

**Nota:** tu `examplePayload` debe coincidir exactamente con el tipo TypeScript del valor de retorno de tu función `perform`.
Si el valor de retorno de la función `perform` no coincide con el tipo de la carga útil de ejemplo, TypeScript generará un mensaje de error útil:


<Screenshot
  filename="custom-components/writing-custom-components/example-result-data-type-mismatch.png"
  maxWidth="600px"
  alt="Ejemplo Resultado Desajuste de tipo de datos en Typescript"
/>

## Funciones utilitarias SOAP

Si estás integrando con una API basada en SOAP, puedes utilizar las [funciones utilitarias del cliente SOAP](spectral/modules/_clients_soap_utils_.md) de Spectral para realizar tareas comunes relacionadas con SOAP.
Por ejemplo, puedes obtener un WSDL, producir un objeto JavaScript que contenga la autenticación o los métodos que define el WSDL, generar encabezados SOAP (para cosas como autenticación) o realizar solicitudes a una API basada en SOAP utilizando sus métodos definidos.

Consulta nuestro [repositorio de ejemplos](https://github.com/-io/examples/tree/main/components/soap-salesforce) para ver un componente de ejemplo que envuelve la API basada en SOAP de Salesforce.

## Agregar conexiones

Una **conexión** es un tipo especial de entrada para una acción que contiene información sobre cómo conectarse a una aplicación o servicio externo.
Una conexión puede constar de una o muchas entradas que pueden representar cosas como puntos finales de API, claves, contraseñas, campos OAuth 2.0, etc.
Las entradas contenidas en una conexión utilizan la misma estructura que otras entradas, descritas [anteriormente](#adding-inputs).

Por ejemplo, supongamos que estás escribiendo un componente para una API que puede recibir una combinación de nombre de usuario y contraseña o una clave de API.
Escribirías dos conexiones: una para la autenticación de nombre de usuario/contraseña y otra para la autenticación de la clave de API.


También deseas que tus clientes puedan apuntar a un entorno de sandbox o producción; cada conexión también debe incluir una entrada para representar el punto de conexión.
Tus conexiones podrían verse así:


```typescript
import { connection } from "@-io/spectral";

// Declara esto una vez, así no nos repetimos para las dos conexiones
const acmeEnvironment = input({
  label: "Acme Inc Environment to Use",
  placeholder: "ACME Environment",
  type: "string",
  required: true,
  model: [
    {
      label: "Production",
      value: "https://api.acme.com/",
    },
    {
      label: "Sandbox",
      value: "https://sandbox.acme.com/api",
    },
  ],
});

const basicAuth = connection({
  key: "basicAuth",
  label: "Acme username and password",
  inputs: {
    username: {
      label: "Acme Username",
      placeholder: "Username",
      type: "string",
      required: true,
    },
    password: {
      label: "Acme Password",
      placeholder: "Password",
      type: "string",
      required: true,
    },
    acmeEnvironment,
  },
});

const apiKey = connection({
  key: "apiKey",
  label: "Acme API Key",
  inputs: {
    username: {
      label: "Acme API Key",
      placeholder: "API Key",
      type: "string",
      required: true,
    },
    acmeEnvironment,
  },
});
```

Una vez que se hayan definido las conexiones, asegúrate de incluirlas en la definición de tu `component`.
Esto permitirá a los usuarios completar la información de la conexión una vez, y esa información se puede utilizar en acciones que requieren esa conexión.
Esto también pone a disposición las conexiones para todas las entradas de tipo "connection" en tu componente:


```typescript {15}
import { component } from "@-io/spectral";

// ...

export default component({
  key: "acme",
  public: false,
  display: {
    label: "Acme Inc",
    description: "Interact with Acme Inc's API",
    iconPath: "icon.png",
  },
  actions: { myAction1, myAction2 },
  triggers: { myTrigger1 },
  connections: [basicAuth, apiKey],
});
```

:::note Pedidos de conexión
La **primera** conexión enumerada en el array `connections:` será la conexión predeterminada.
En el ejemplo anterior, `basicAuth` sería la conexión predeterminada para este componente.
La conexión predeterminada es la que se recomienda a los usuarios cuando agregan una acción de tu componente a su integración, pero también se pueden seleccionar otros tipos de conexión.

:::

### Haciendo referencia a conexiones como inputs en acciones

Las acciones pueden hacer referencia a conexiones como lo hacen con cualquier otro input.

Para dar a los usuarios la capacidad de asignar una conexión a una acción, crea un `input` de tipo `connection` y agrégalo como un input a tu acción:


```typescript {3,10-11,14,16} title="Hacer referencia a una entrada de conexión de una acción"
import { action, input } from "@-io/spectral";

const connectionInput = input({ label: "Connection", type: "connection" });

export const getAcmeData = action({
  display: {
    label: "Get Item",
    description: "Get an Item from Acme",
  },
  inputs: { itemId: itemIdInput, myConnection: connectionInput },
  perform: async (context, { itemId, myConnection }) => {
    const response = axios({
      method: "get",
      url: `${myConnection.fields.acmeEnvironment}/item/${itemId}`,
      headers: {
        Authorization: `Bearer ${myConnection.fields.apiKey}`,
      },
    });
    return { data: response.data };
  },
});
```

### Lanzando errores de conexión

Es valioso saber si una conexión es válida o no, y realizar un seguimiento de los errores cuando una conexión no puede establecerse.
Dentro de tu componente personalizado, puedes lanzar un `ConnectionError` para señalar que hay algo mal con la conexión (incapaz de conectarse al punto final, credenciales no válidas, etc).

Por ejemplo, si sabes que la API con la que integras devuelve un código 401 "No autorizado" cuando las credenciales no son válidas, podrías lanzar un `ConnectionError` si tu cliente HTTP devuelve un código de estado 401:


```typescript {1,13-18} title="Throw a connection error"
import { action, ConnectionError, util } from "@-io/spectral";

const getItem = action({
  display: {
    label: "Get Item",
    description: "Get an item from Acme",
  },
  perform: async (context, { myConnection, itemId }) => {
    const apiKey = util.types.toString(myConnection.fields.apiKey);
    const response = await axios.get(`https://api.acme.com/items/${itemId}`, {
      headers: { Authorization: apiKey },
    });
    if (response.status === 401) {
      throw new ConnectionError(
        myConnection,
        "Invalid Acme credentials have been configured."
      );
    }
    return {
      data: response.data,
    };
  },
  inputs: {
    myConnection: input({ label: "Connection", type: "connection" }),
    itemId: itemIdInput,
  },
});
```

### Escritura de conexiones OAuth 2.0

Una conexión de código de autorización OAuth 2.0 sigue el protocolo [OAuth 2.0](https://oauth.net/2/) y consta de cinco entradas requeridas:

- `authorizeUrl` - La URL que un usuario visita para autorizar una conexión OAuth 2.0.
- `tokenUrl` - La URL donde un código de autorización se puede intercambiar por una clave de API y una clave de actualización opcional, y donde una clave de actualización se puede usar para actualizar una clave de API.
- `scopes` - Una lista de alcances (permisos) delimitados por espacios que necesita tu aplicación.
- `clientId` - El identificador de cliente de tu aplicación OAuth 2.0.
- `clientSecret` - El secreto de cliente de tu aplicación OAuth 2.0.

Los tres primeros campos generalmente se pueden encontrar en la documentación de la API con la que estás integrando.
El ID de cliente y el secreto de cliente se crean al crear una aplicación en la aplicación de terceros.

Puedes optar por dar a los creadores de integraciones la capacidad de editar cualquiera de estos campos.
O puedes marcar los campos como `shown: false`, en cuyo caso siempre se usará el valor predeterminado y los desarrolladores de integración nunca verán el valor.

Por ejemplo, si estás escribiendo una conexión OAuth 2.0 para Google Drive, las URL de `authorizeUrl` y `tokenUrl` nunca cambian.
Entonces, se les pueden asignar valores predeterminados y se pueden marcar como `shown: false`.
Los desarrolladores de integración querrán poder ajustar los alcances, el ID de cliente y el secreto de cliente (aunque es posible que ya sepas qué alcances necesitas), así que podemos escribir una conexión como esta:


```typescript {8,16,18,25,27} title="Ejemplo de conexión OAuth 2.0 con Google Drive"
import { oauth2Connection, OAuth2Type } from "@-io/spectral";

export const oauth2 = oauth2Connection({
  key: "googleDriveOauth",
  label: "OAuth2",
  comments: "OAuth2 Connection",
  required: true,
  oauth2Type: OAuth2Type.AuthorizationCode,
  iconPath: "oauth-icon.png",
  inputs: {
    authorizeUrl: {
      label: "Authorize URL",
      placeholder: "Authorization URL",
      type: "string",
      required: true,
      shown: false,
      comments: "The Authorization URL for Google Drive.",
      default: "https://accounts.google.com/o/oauth2/v2/auth",
    },
    tokenUrl: {
      label: "Token URL",
      placeholder: "Token URL",
      type: "string",
      required: true,
      shown: false,
      comments: "The Token URL for Google Drive.",
      default: "https://oauth2.googleapis.com/token",
    },
    scopes: {
      label: "Scopes",
      placeholder: "Scopes",
      type: "string",
      required: true,
      comments:
        "Space delimited listing of scopes. https://developers.google.com/identity/protocols/oauth2/scopes#drive",
      default: "https://www.googleapis.com/auth/drive",
    },
    clientId: {
      label: "Client ID",
      placeholder: "Client Identifier",
      type: "password",
      required: true,
      comments: "The Google Drive app's Client Identifier.",
    },
    clientSecret: {
      label: "Client Secret",
      placeholder: "Client Secret",
      type: "password",
      required: true,
      comments: "The Google Drive app's Client Secret.",
    },
  },
});
```

:::tip Utiliza `oauth2Connection` para conexiones OAuth

Ten en cuenta que utilizamos `oauth2Connection()` en lugar de `connection()` para definir esta conexión OAuth.
Esto se debe a que la función auxiliar `oauth2Connection` nos proporciona sugerencias adicionales de TypeScript sobre qué campos son obligatorios.
:::

Una `oauth2Connection` se puede asignar a un componente y referenciar como una entrada al igual que una `connection`.
La entrada que recibe una función `perform` tendrá la siguiente forma:


```json example contents of an oauth 2.0 connection input object
{
  "token": {
    "access_token": "EXAMPLE-TOKEN",
    "token_type": "bearer",
    "expires_in": 14400,
    "refresh_token": "EXAMPLE-REFRESH-TOKEN",
    "scope": "account_info.read account_info.write file_requests.read file_requests.write files.content.read files.content.write files.metadata.read files.metadata.write",
    "uid": "123456789",
    "account_id": "dbid:EXAMPLEIRNhsZ3wECJZ3aXK3Gm47Di74",
    "expires_at": "2021-12-07T01:54:38.096Z"
  },
  "context": {
    "code": "EXAMPLEqMEAAAAAAAAON5iBXhk_yOxjkfDeWy_vSE0",
    "state": "EXAMPLE2VDb25maWdWYXJpYWJsZTpmMDZlMDVkNy1kMjY0LTQ0YTgtYWI0Ni01MDhiOTNmZjU5ZjI="
  },
  "instanceConfigVarId": "EXAMPLE2VDb25maWdWYXJpYWJsZTpmMDZlMDVkNy1kMjY0LTQ0YTgtYWI0Ni01MDhiOTNmZjU5ZjI=",
  "key": "oauth",
  "fields": {
    "scopes": "",
    "clientId": "example-client-id",
    "tokenUrl": "https://api.dropboxapi.com/oauth2/token",
    "authorizeUrl": "https://www.dropbox.com/oauth2/authorize?token_access_type=offline",
    "clientSecret": "example-client-secret"
  }
}
```

Es probable que desees hacer referencia a `myConnection.token.access_token`.


:::tip Añadir un botón personalizado a tu Conexión OAuth 2.0
Puedes especificar cómo se ve el botón OAuth 2.0 en la página de configuración de la instancia mediante la especificación opcional de `iconPath` (ver el ejemplo anterior).
Un ícono debe ser un archivo PNG, y recomendamos que sea más ancho que alto, con texto que indique su función:


<Screenshot
  filename="custom-components/writing-custom-components/oauth-buttons.png"
  maxWidth="200px"
  alt="Botones OAuth, incluidos Dropbox, Facebook, GitHub, Google, Tumblr y Twitter"
/>

Sin un `iconPath`, se colocará un botón simple que dice **CONECTAR** en la página de configuración.

:::

### Admitir PKCE con OAuth 2.0

Si la aplicación con la que estás integrando admite [Proof Key for Code Exchange](https://oauth.net/2/pkce/) (PKCE), puedes agregar PKCE a tu conexión OAuth 2.0 añadiendo una propiedad `oauth2PkceMethod`.
Puedes especificar el método `plain` o `S256`, o omitir la propiedad para especificar "sin PKCE".


```ts title="Ejemplo de declaración PKCE" {3}
export const oauth = oauth2Connection({
  oauth2Type: OAuth2Type.AuthorizationCode,
  oauth2PkceMethod: OAuth2PkceMethod.S256,
  key: "oauth",
  label: "Airtable OAuth 2.0",
  inputs: {
    // ...
  },
});
```

### Uso de conexiones con clientes HTTP

Aunque la mayoría de las APIs con las que interactuarás están basadas en HTTP y presentan una interfaz RESTful, no todas son iguales.
Algunas APIs (como 's!) utilizan GraphQL.
Otras utilizan llamadas a procedimientos remotos (RPC), como gRPC, XML RPC o SOAP.

Afortunadamente, hay un paquete [NPM](https://www.npmjs.com/) para casi cualquier protocolo.

- Si estás trabajando con una API **REST basada en HTTP**, recomendamos utilizar la función integrada de Spectral [createClient](spectral/modules/_clients_http_index_.md#const-createclient), que crea un cliente HTTP [Axios](https://axios-http.com/docs/intro) detrás de escena con algunas configuraciones útiles preconfiguradas (ver [ejemplo](#usando-el-cliente-http-createclient-integrado) a continuación).
  Si tu equipo se siente más cómodo con Axios o [node-fetch](https://www.npmjs.com/package/node-fetch), también puedes utilizarlos.
- Para APIs **GraphQL**, recomendamos usar [graphql-request](https://www.npmjs.com/package/graphql-request).
  Puedes usar un cliente HTTP genérico, pero `graphql-request` proporciona una práctica etiqueta literal de cadena `gql`.
- Para APIs **XML RPC**, puedes importar [xmlrpc](https://www.npmjs.com/package/xmlrpc) en tu proyecto de componente, o puedes optar por [soap](https://www.npmjs.com/package/soap) si es una **API SOAP**.
- Es mucho menos común para integraciones de API HTTP, pero [@grpc/grpc-js](https://www.npmjs.com/package/@grpc/grpc-js) se puede utilizar para **APIs gRPC**.

Independientemente del cliente que utilices, es probable que necesites configurar algunas cabeceras HTTP para la autenticación, el tipo de contenido, etc.

### Usando el cliente HTTP createClient integrado

Spectral viene con un cliente HTTP integrado para integrarse con APIs REST.
Detrás de escena, `createClient` crea un cliente HTTP basado en Axios con ciática de tiempo de espera, reintentos y lógica de depuración incorporada.
Puedes ver el código fuente de `createClient` en el repositorio de GitHub de Spectral [aquí](https://github.com/-io/spectral/blob/main/packages/spectral/src/clients/http/index.ts).


Para crear un cliente HTTP, proporciona al cliente una URL base para tu API junto con la información de encabezado que necesitas para la autenticación.
Puedes obtener los valores de autenticación de una conexión.
Podría parecer algo así:


```typescript title="Ejemplo de uso de createClient"
import { createClient } from "@-io/spectral/dist/clients/http";

action({
  perform: async (context, params) => {
    // Create the authenticated HTTP client
    const myClient = createClient({
      baseUrl: "https://example.com/api",
      debug: false,
      headers: {
        "X-API-Key": params.connection.fields.apiKey,
        Accept: "application/json",
      },
      responseType: "json",
    });

    // Utilizar el cliente HTTP para enviar datos POST a la API
    const response = await myClient.post("/items", {
      sku: "12345",
      quantity: 3,
      price: 20.25,
    });

    // Devolver la respuesta como resultado de la acción
    return { data: response.data };
  },
});
```

:::tip Depuración de una conexión HTTP
Si deseas ver el contenido completo de la solicitud y la respuesta HTTP, establece `debug: true`.
Verás todos los puntos finales, encabezados, códigos de respuesta, etc. en los registros de integración.

¡Recuerda apagar la depuración para producción!

:::

## Manejadores globales de errores

Las acciones en tu componente pueden envolver todos los puntos finales de la API utilizando un cliente HTTP, y ese cliente puede lanzar ciertos errores.
Podrías manejar esos errores dentro de cada acción, pero terminarías escribiendo los mismos manejadores de errores una y otra vez.

Ahora puedes especificar una función de manejador de errores que se ejecutará cada vez que cualquiera de tus acciones lance un error.
Para especificar un manejador de errores, agrega un bloque `handlers` a la definición de tu función `component({})`:


```typescript
components({
  // ...
  hooks: {
    error: (error) => doSomething(error),
  },
});
```

Por ejemplo, el popular cliente HTTP [axios](https://www.npmjs.com/package/axios) lanza un error cada vez que recibe un código de estado que _no_ está entre 200 y 299 ([fuente](https://github.com/axios/axios/blob/1f13dd7e26124a27c373c83eff0a8614acc1a04f/lib/defaults/index.js#L127-L129)).
Si tu cliente HTTP recibe un código de estado en el rango 4xx o 5xx, se lanza un error con un mensaje mínimo.
Si deseas obtener información adicional, como el código de estado o la respuesta completa de la solicitud HTTP, puedes inspeccionar el error que se está lanzando y devolver un mensaje de error más detallado, como se ilustra en Spectral [aquí](https://github.com/-io/spectral/blob/v6.5.0/packages/spectral/src/clients/http/index.ts#L53-L62).

## Exportar un componente

El código del componente contiene una exportación predeterminada del tipo `component`.
Un `componente` contiene una `clave` que lo identifica de manera única, si es o no `público`, información sobre cómo la aplicación web debe `mostrarlo`, un objeto que contiene las `acciones` de las que consta el componente y, si tu componente personalizado tiene sus propios [disparadores](#writing-triggers), un objeto que contiene los `triggers` que contiene el componente.

Para el ejemplo del componente "nombres correctos e incorrectos", la exportación puede verse así:


```typescript
export default component({
  key: "format-name",
  public: false,
  display: {
    label: "Format Name",
    description: "Formatear el nombre de una persona a partir de su nombre, segundo nombre y apellidos",
    iconPath: "icon.png",
  },
  actions: {
    improperFormatName,
    properFormatName,
  },
  connections: [basicAuth, apiKey],
});
```

## Pruebas unitarias para componentes personalizados

Es importante tener buenas pruebas unitarias para el software, y los componentes personalizados no son una excepción. Quieres detectar errores o cambios que rompan el código antes de que causen estragos en las integraciones de tus clientes. La biblioteca Spectral de 's proporciona algunas funciones de utilidad para facilitar la escritura de pruebas unitarias.

En los ejemplos a continuación, asumimos que estás utilizando el marco de pruebas [Jest](https://jestjs.io/), que se instala por defecto al ejecutar `prism components:init`. Puedes cambiar Jest por otro marco de pruebas si lo prefieres.

### Convenciones de nomenclatura de archivos de pruebas

Para crear un archivo de prueba unitaria, crea un nuevo archivo junto con tu código que tenga la extensión `test.ts` (en lugar de `.ts`). Por ejemplo, si tu código está en `index.ts`, crea un archivo llamado `index.test.ts`. Si separas las acciones de tu componente en `actions.ts`, crea un archivo correspondiente llamado `actions.test.ts`.

### Pruebas de acciones del componente

Como se describe [arriba](#perform-function-parameters), la función `perform` de una acción del componente toma dos argumentos:

- `context` es un objeto que contiene un `logger`, `executionId`, `instanceState` y `stepId`.
- `params` es un objeto que contiene parámetros de entrada como pares clave-valor.

Los parámetros de prueba `context` se describen a continuación. Ignoremos por ahora y veamos el objeto `params`.

Considere la acción de ejemplo "Formatear nombre adecuado" descrita anteriormente:


```typescript
export const properFormatName = action({
  display: {
    label: "Properly Format Name",
    description: "Properly format a person's name (Last, First M.)",
  },
  perform: async (context, params) => {
    if (params.middleName) {
      return {
        data: `${params.lastName}, ${params.firstName} ${params.middleName[0]}.`,
      };
    } else {
      return { data: `${params.lastName}, ${params.firstName}` };
    }
  },
  inputs: { firstName, middleName, lastName },
});
```

Puede utilizar la clase [`ComponentTestHarness`](spectral/classes/_testing_.componenttestharness.md) y la función auxiliar [`createHarness`](spectral/modules/_testing_.md#const-createharness) para probar sus acciones.

La función `action` del arnés de prueba toma dos parámetros obligatorios y uno opcional:

- La clave de la acción (por ejemplo, `properFormatName`)
- Un objeto que contiene los parámetros de entrada
- Un objeto `context` opcional que contiene `logger`, `executionId`, `instanceState` y `stepId`

Entonces, un archivo de prueba de Jest podría verse así:


```typescript
import component from ".";
// highlight-next-line
import { createHarness } from "@-io/spectral/dist/testing";

// highlight-next-line
const harness = createHarness(component);

describe("Test the Proper Name formatter", () => {
  test("Verify first, middle, and last name", async () => {
    // highlight-next-line
    const result = await harness.action("properFormatName", {
      firstName: "John",
      middleName: "James",
      lastName: "Doe",
    });
    expect(result.data).toStrictEqual("Doe, John J.");
  });
  test("Verify first and last name without middle", async () => {
    // highlight-next-line
    const result = await harness.action("properFormatName", {
      firstName: "John",
      middleName: null,
      lastName: "Doe",
    });
    expect(result.data).toStrictEqual("Doe, John");
  });
});
```

Luego puede ejecutar `yarn run jest`, y Jest ejecutará cada prueba, devolviendo un código de error si una prueba falla.

### Verificación de registros correctos en pruebas de acciones

Es posible que desee verificar que su acción genere algunos registros de gravedades particulares en ciertas situaciones.
Además de los resultados de los pasos, la función [`invoke`](spectral/modules/_testing_.md#const-invoke) de la utilidad de prueba devuelve un objeto `loggerMock` con información sobre lo que se registró durante la invocación de la acción.

Puede utilizar Jest para verificar que se registraron ciertas líneas de la siguiente manera:

```typescript
import { myExampleAction } from "./actions";
import { invoke } from "@-io/spectral/dist/testing";

test("Ensure that an error is logged", async () => {
  const level = "error";
  const message = "Error code 42 occurred.";
  const { loggerMock } = await invoke(myExampleAction, {
    exampleInput1: "exampleValue1",
    exampleInput2: "exampleValue2",
  });
  expect(loggerMock[level]).toHaveBeenCalledWith(message);
});
```

En el ejemplo anterior, la prueba pasaría si se generara una línea de registro de `error` que dijera `Ocurrió el error código 42`, y fallaría en caso contrario.

### Proporcionar entradas de conexión de prueba para una prueba de acción

Muchas acciones requieren una conexión para interactuar con servicios de terceros.
Puede crear un objeto de conexión con la función `createConnection` de `@-io/spectral/dist/testing`:

```typescript
import { createConnection, createHarness } from "@-io/spectral/dist/testing";
import component from ".";
import { myConnection } from "./connections";

const harness = createHarness(component);

const myBasicAuthTestConnection = createConnection(myConnection, {
  username: "myUsername",
  password: "myPassword",
});

describe("test my action", () => {
  test("verify the return value of my action", async () => {
    const result = await harness.action("myAction", {
      someInput: "abc-123",
      connection: myBasicAuthTestConnection,
      someOtherInput: "def-456",
    });
  });
});
```

No es una buena práctica codificar secretos de autorización directamente.
Por favor, utiliza buenas prácticas, como establecer variables de entorno para almacenar secretos en tu entorno de CI/CD:


```typescript
import { createConnection } from "@-io/spectral/dist/testing";
import { myConnection } from "./connections";

const myBasicAuthTestConnection = createConnection(myConnection, {
  username: process.env.ACME_ERP_USERNAME,
  password: process.env.ACME_ERP_PASSWORD,
});
```

:::tip Utiliza las Conexiones Existentes de una Integración para Pruebas
Si deseas obtener una clave de acceso de una conexión OAuth 2.0 existente en una integración (o nombre de usuario/contraseña, clave API, etc.), aprovecha el comando `prism components:dev:run` para obtener los campos y tokens de la conexión.
Luego, puedes hacer referencia a la variable de entorno `_CONNECTION_VALUE` en tus pruebas Jest.

Más información en nuestra [documentación de prism](cli/prism.mdx#componentsdevrun).

:::

## Pruebas de componentes desde la CLI

La herramienta de línea de comandos [`prism`](cli/cli-usage.mdx) proporciona dos comandos para probar componentes personalizados:

- `prism components:dev:run` obtiene una conexión activa de una integración y guarda los campos como una variable de entorno para que puedas ejecutar [pruebas unitarias](#unit-tests-for-custom-components) y otros comandos localmente.
  Esto es útil, ya que muchas pruebas unitarias requieren un token de acceso de una conexión OAuth 2.0 validada; esto proporciona una forma de obtener el token de una conexión que ya has autenticado en el diseñador de integraciones.
- `prism components:dev:test` publica tu componente bajo un nombre temporal y ejecuta una integración de prueba de acción única que prueba la acción.
  Esto es útil para probar rápidamente una acción en el entorno real del ejecutor de integraciones.

### Acceder a conexiones para pruebas locales

El comando `prism components:dev:run` obtiene una conexión activa del diseñador de integraciones, para que puedas utilizar los campos de la conexión en las pruebas unitarias.
Los valores de la conexión se establecen en una variable de entorno llamada `_CONNECTION_VALUE`, que puede ser utilizada por un comando posterior.


En este ejemplo, usamos `printenv` para imprimir la variable de entorno y dirigimos el resultado a [jq](https://stedolan.github.io/jq/) para una presentación más ordenada:


```bash
prism components:dev:run \
  --integrationId SW50ZEXAMPLE \
  --connectionKey "Dropbox Connection" -- printenv _CONNECTION_VALUE | jq

{
  "token": {
    "access_token": "sl.EXAMPLE",
    "token_type": "bearer",
    "expires_in": 14400,
    "expires_at": "2022-10-13T20:09:53.739Z",
    "refresh_token": "EXAMPLE"
  },
  "context": {
    "code": "sU4pEXAMPLE",
    "state": "SW5zdEXAMPLE"
  },
  "fields": {
    "clientId": "EXAMPLE",
    "clientSecret": "EXAMPLE"
  }
}
```

Tenga en cuenta que el comando que desea ejecutar con la variable de entorno debe seguir a un `--`.

Dentro de tu código de prueba unitaria, puedes usar `harness.connectionValue()`, que extrae la variable de entorno `_CONNECTION_VALUE` en una conexión que puedes utilizar para las pruebas:


```typescript title="Utilice _CONNECTION_VALUE para una prueba Jest"
import { createHarness } from "@-io/spectral/dist/testing";
import { oauthConnection } from "./connections";
import component from ".";

// Inicializar un arnés de pruebas
const harness = createHarness(component);

// Analizar la conexión OAuth 2.0 a partir de la variable de entorno _CONNECTION_VALUE
const parsedConnection = harness.connectionValue(oauthConnection);

describe("listFolder", () => {
  test("listRootFolder", async () => {
    const result = await harness.action("listFolder", {
      dropboxConnection: parsedConnection, // Pass in our connection
      path: "/",
    });
    const files = result["data"]["result"]["entries"];
    // Verify a folder named "Public" exists in the response
    expect(files).toEqual(
      expect.arrayContaining([expect.objectContaining({ name: "Public" })])
    );
  });
});
```

A continuación, desde su componente, puede ejecutar:

```bash
prism components:dev:run \
  --integrationId SW50ZEXAMPLE \
  --connectionKey "Dropbox Connection" -- npm run jest
```

### Ejecutar una prueba de una acción desde la línea de comandos

El comando `prism components:dev:test` te permite probar una acción rápidamente desde la línea de comandos en el entorno real de ejecución de integraciones.

- Ejecuta `prism components:dev:test` desde el directorio raíz de tu componente.
- Se te pedirá que selecciones una acción para probar. Selecciona una.
- Para cada entrada de la acción, proporciona un valor.
- Si tu acción requiere una conexión, se te pedirá los valores para esa conexión (nombre de usuario, contraseña, client_id, etc.).
  - Si tu acción requiere una conexión OAuth 2.0, se abrirá un navegador web para manejar el flujo OAuth.

Una vez que se introduzcan todas las entradas, tu acción se ejecutará en el entorno de ejecución de integraciones, y verás los registros de tu acción.

#### Archivos de entorno para ejecuciones de prueba

No es necesario introducir las mismas entradas cada vez que quieras ejecutar una prueba de tu acción.
Para establecer algunos valores para tus entradas de prueba, crea un nuevo archivo llamado `.env` en el mismo directorio desde donde estás invocando `prism` e introduce tus entradas y valores como pares clave/valor.
Por ejemplo, si planeas dejar en blanco las entradas `cursor` y `limit`, establecer `path` en `/`, y tienes un ID de cliente y un secreto de cliente OAuth que deseas utilizar cada vez, tu archivo `.env` puede verse así:

```text tile="Ejemplo de archivo .env para probar acciones desde la línea de comandos"
CURSOR=
LIMIT=
PATH=/
CLIENT_ID=xlexample
CLIENT_SECRET=4yexample
```

## Writing triggers

Integrations are usually triggered [on a schedule](integration-triggers.mdx#scheduled-triggers) (meaning instances of the integration run every X minutes, or at a particular time of day) or [via webhook](integration-triggers.mdx#webhook-triggers) (meaning some outside system sends JSON data to a unique URL and an instance processes the data that was sent).
The vast majority of integrations built in start with a schedule trigger or webhook trigger.
There are situations, though, where neither the schedule nor the standard webhook trigger are suitable for one reason or another.
That's where writing your own triggers come in handy.

Triggers are custom bits of code that are similar to [actions](#writing-actions).
They give you fine-grained control over how a webhook's payload is presented to the rest of the steps of an integration and what HTTP response is returned to whatever invoked the trigger's webhook URL.

Similar to an action, a trigger is comprised of `display` information, a `perform` function and `inputs`.
Additionally, you specify if your trigger can be invoked [synchronously](integration-triggers.mdx#synchronous-and-asynchronous-integrations) (`synchronousResponseSupport`) and if your trigger supports scheduling (`scheduleSupport`).

Suppose, for example, a third-party app can be configured to send CSV data via webhook and requires that the webhook echo a header, `x-confirmation-code`, back in plaintext to confirm it got the payload.
The default webhook trigger accepts JSON, and responds with an [execution ID](api/schema/object/InstanceExecutionResult.mdx#return-fields), so it's not suitable for integrating with this third-party app.

This trigger will return an HTTP 200 and echo a particular header back to the system invoking the webhook, and then it'll parse the CSV payload into an object so that subsequent steps can reference through the trigger's `results.body.data`:

```typescript
import {
  input,
  trigger,
  TriggerPayload,
  HttpResponse,
  util,
} from "@-io/spectral";
import papaparse from "papaparse"; // CSV Library

export const csvTrigger = trigger({
  display: {
    label: "CSV Webhook",
    description:
      "Accepts and parses CSV data into a referenceable object and returns a plaintext ACK to the webhook caller.",
  },
  perform: async (context, payload, { hasHeader }) => {
    // Create a custom HTTP response that echos a header,
    // x-confirmation-code, that was received as part of
    // the webhook invocation
    const response: HttpResponse = {
      statusCode: 200,
      contentType: "text/plain; charset=utf-8",
      body: payload.headers["x-confirmation-code"],
    };

    // Create a copy of the webhook payload, deserialize
    // the CSV raw body, and add the deserialized object
    // to the object to the trigger's outputs
    const finalPayload: TriggerPayload = { ...payload };

    const parseResult = papaparse.parse(
      util.types.toString(payload.rawBody.data),
      {
        header: util.types.toBool(hasHeader),
      }
    );

    finalPayload.body.data = parseResult.data;

    // Return the modified trigger payload and custom HTTP response
    return Promise.resolve({
      payload: finalPayload,
      response,
    });
  },
  inputs: {
    // Declare if the incoming CSV has header information
    hasHeader: input({
      label: "CSV Has Header",
      type: "boolean",
      default: "false",
    }),
  },
  synchronousResponseSupport: "invalid", // Do not allow synchronous invocations
  scheduleSupport: "invalid", // Do not allow scheduled invocations
});

export default { csvTrigger };
```

Notice a few things about this example:

- The `trigger`'s form is very similar to that of an `action` definition.
- The `response` contains an HTTP `statusCode`, `body`, and `contentType` to be returned to the webhook caller.
- The second argument to the `perform` function - `payload` - contains the same information that a standard webhook trigger returns.
  The `rawBody.data` presumably contains some CSV text - the `body.data` key of the payload is replaced by the deserialized version of the CSV data.
- `inputs` work the same way that they work for actions - you define a series of `input`s, and they're passed in as the third parameter of the `perform` function.

For another real-world example of writing a trigger, check out our tutorial on how we [wrote the Salesforce trigger](quickstarts/writing-a-trigger.mdx).

### Instance deploy and delete events for triggers

Similar to a `perform` function, a trigger can also define `onInstanceDeploy` and `onInstanceDelete` functions.
These functions are called when an instance is deployed or deleted, respectively.
They are handy for creating or deleting resources in a third-party system that are associated with an instance (like file directories, webhooks, etc).

This example trigger will create a webhook in a third-party app when an instance is deployed, storing the webhook ID in persistant data, and delete the webhook when the instance is deleted:

```typescript
const acmeWebhookTrigger = trigger({
  display: {
    label: "Acme Webhook Trigger",
    description: "Acme will notify your app when certain events occur in Acme",
  },
  scheduleSupport: "invalid",
  synchronousResponseSupport: "invalid",
  inputs: {
    connection: input({
      label: "Acme Connection",
      type: "connection",
      required: true,
    }),
    events: input({
      type: "string",
      label: "Events",
      comments:
        "The events that would cause an Acme webhook request to be sent to this flow",
      collection: "valuelist",
      model: [
        { label: "Lead Created", value: "lead_created" },
        { label: "Lead Updated", value: "lead_updated" },
        { label: "Lead Deleted", value: "lead_deleted" },
      ],
    }),
  },

  /** Run when a trigger is invoked. This function could contain additional logic for verifying HMAC signatures, etc. */
  perform: async (_context, payload, _params) => {
    return Promise.resolve({ payload });
  },

  /** Run when an instance with this trigger is deployed */
  onInstanceDeploy: async (context, params) => {
    // Get the current flow's webhook URL
    const flowWebhookUrl = context.webhookUrls[context.flow.name];

    // Create a webhook in Acme
    const { data } = await axios.post(
      "https://api.acme.com/webhooks",
      {
        endpoint: flowWebhookUrl,
        events: params.events,
      },
      {
        headers: {
          Authorization: `Bearer ${params.connection.token?.access_token}`,
        },
      }
    );

    // Store the webhook ID in the instance state
    return {
      instanceState: { webhookId: data.id },
    };
  },

  /** Run when an instance with this trigger is removed */
  onInstanceDelete: async (context, params) => {
    // Get the webhook ID from the instance state
    const webhookId = context.instanceState["webhookId"];

    // Delete the webhook from Acme
    await axios.delete(`https://api.acme.com/webhooks/${webhookId}`, {
      headers: {
        Authorization: `Bearer ${params.connection.token?.access_token}`,
      },
    });
  },
});
```

:::tip Ensure your onInstanceDeploy function is idempotent
Either the external third-party API, or your trigger, should be designed to be idempotent - meaning that if the `onInstanceDeploy` is created twice, it won't cause any problems.
:::

### Add a trigger to your component

Once you've written a trigger, you can add it to an existing component the same way you add an action to your component, but using the `triggers` key:

```typescript {1,15}
import { csvTrigger } from "./csvTrigger";

export default component({
  key: "format-name",
  public: false,
  display: {
    label: "Format Name",
    description: "Format a person's name given a first, middle, and last name",
    iconPath: "icon.png",
  },
  actions: {
    improperFormatName,
    properFormatName,
  },
  triggers: { csvTrigger },
});
```

### Testing a trigger

Testing a trigger is similar to [testing an action](#testing-component-actions), except you use the [harness.trigger](spectral/classes/_testing_.componenttestharness.md#trigger) function instead.
For example, if you want to use Jest to test the `csvTrigger` outlined above, your test could look like this:

```typescript
import component from ".";
import {
  createHarness,
  defaultTriggerPayload,
} from "@-io/spectral/dist/testing";

const harness = createHarness(component);

describe("test csv webhook trigger", () => {
  test("verify the return value of the csv webhook trigger", async () => {
    const payload = defaultTriggerPayload(); // The payload you can expect a generic trigger to receive

    payload.rawBody.data = "first,last,age\nJohn,Doe,30\nJane,Doe,31";
    payload.headers.contentType = "text/csv";
    payload.headers["x-confirmation-code"] = "some-confirmation-code-123";

    const expectedData = [
      { first: "John", last: "Doe", age: "30" },
      { first: "Jane", last: "Doe", age: "31" },
    ];

    const expectedResponse = {
      statusCode: 200,
      contentType: "text/plain; charset=utf-8",
      body: payload.headers["x-confirmation-code"],
    };

    const {
      payload: {
        body: { data },
      },
      response,
    } = await harness.trigger("csvTrigger", null, payload, {
      hasHeader: true,
    });

    expect(data).toStrictEqual(expectedData);
    expect(response).toStrictEqual(expectedResponse);
  });
});
```

## Writing data sources

A **Data Source** fetches data from a third-party API that will be used to dynamically generate a config variable.
When your customer deploys an instance, they use a [connection](#adding-connections) to authenticate with a third-party API.

A data source can generate a variety of [types of data](https://github.com/-io/spectral/blob/main/packages/spectral/src/types/DataSourceResult.ts) including a `string`, `date`, `picklist` (which is a `string[]`), complex `objectSelection` objects, and more.

Here's a simple data source that fetches an array of customers, each with a `name` and `id`.
It maps them to a `label`/`key` object so the customer's names show in a `picklist`, and the customer's `id` is :

```typescript title="Fetch a string from an external API"
import { dataSource, Element } from "@-io/spectral";

interface Customer {
  name: string;
  id: string;
}

const companyName = dataSource({
  display: {
    label: "Fetch Customers",
    description: "Fetch an array of customers' names",
  },
  inputs: {
    connection: input({
      label: "Connection",
      type: "connection",
      required: true,
    }),
  },
  perform: async (context, params) => {
    const client = createAcmeClient(params.connection);
    const response = await client.get<{ customers: Customer[] }>("/customers");
    const customers = response.data.customers?.map<Element>((customer) => ({
      label: customer.name,
      key: customer.id,
    }));
    return { result: customers };
  },
  dataSourceType: "picklist",
  examplePayload: {
    result: [
      { label: "Smith Rocket Company", key: "abc-123" },
      { label: "Mars Rocket Corp", key: "def-456" },
    ],
  },
});
```

In this example, we fetch several items from an API, including metadata about each item, so that a user can select one or more of the items and get that metadata of each:

```typescript title="Fetch a string from an external API"
const companyName = dataSource({
  display: {
    label: "Fetch Items",
    description: "Fetch all available items",
  },
  inputs: {
    connection: input({
      label: "Connection",
      type: "connection",
      required: true,
    }),
  },
  perform: async (context, params) => {
    const client = createAcmeClient(params.connection);
    const response = await client.get("/items");
    const objects: ObjectSelection = response.data.items.map((item) => ({
      object: { key: object.id, label: object.name },
      fields: [
        { key: object.quantity, label: "Quantity" },
        { key: object.sku, label: "SKU" },
      ],
    }));
    return { result: response.data.name };
  },
  dataSourceType: "objectSelection",
  examplePayload: {
    result: [
      {
        object: { key: "abc-123", label: "widgets" },
        fields: [
          { key: "5", label: "Quantity" },
          { key: "0000000000", label: "SKU" },
        ],
      },
    ],
  },
});
```

An example of a data source that generates a picklist is available in the [Slack component](https://github.com/-io/examples/blob/main/components/slack/src/dataSources.ts).

## JSON Forms Data Sources

[JSON Forms](https://jsonforms.io/) is a form-generating framework that allows you to create forms through JSON schema that you generate.
A JSON Form can contain any number of string, boolean, number, date, time, datetime or enum (dropdown menu) inputs, and you have some control over how the input elements are rendered (in tabs, grouped, vertical or horizontal layout, etc).

Full documentation on JSON Forms is available on their [documentation page](https://jsonforms.io/examples), including several examples.
offers a <a href='/jsonforms/playground/'>JSON Forms playground</a> where you can create new forms and see how they would be rendered in .

A JSON Form config data source must return two properties (and one optional property):

- `schema` defines the types of inputs your form contains (its `properties`), and some optional validators, like which properties are required.
- `uiSchema` defines how those inputs should be rendered, like whether the inputs should be vertically or horizontally aligned.
- `data` (optional) allows you to specify some default values for your form inputs.

This simple example's `schema` declares two inputs - `name` (a string) and `age` (an integer between 0 and 150), and the `uiSchema` labels the first input "First Name" and places the input fields horizontally next to one another.

```typescript title="A simple JSON Form"
return {
  result: {
    schema: {
      type: "object",
      properties: {
        name: {
          type: "string",
        },
        age: {
          type: "integer",
          minimum: 0,
          maximum: 150,
        },
      },
    },
    uiSchema: {
      type: "HorizontalLayout",
      elements: [
        {
          type: "Control",
          scope: "#/properties/name",
        },
        {
          type: "Control",
          scope: "#/properties/age",
        },
      ],
    },
    data: { name: "Bob", age: 20 },
  },
};
```

The resulting JSON Form looks like this:

<Screenshot
  filename="custom-components/writing-custom-components/json-forms/simple-example-result.png"
  maxWidth="600px"
  alt="Simple JSON form config variable"
/>

### Data Mapping with JSON Forms

A common use-case for JSON Forms is presenting a data-mapping UI to a user.
For the sake of illustration, we'll pull down [users](https://jsonplaceholder.typicode.com/users) and [to-do tasks](https://jsonplaceholder.typicode.com/todos?_limit=10) from [JSON Placeholder](https://jsonplaceholder.typicode.com/), and give our users the ability to map any number of users to tasks.

In order to provide any number of mappings of user-to-task, our JSON schema will need to contain an [`array`](https://jsonforms.io/examples/array) of `object`.
Each `object` will contain a `user` property and a `task` property.
The `user` and `task` property will each have a [`oneOf`](https://jsonforms.io/docs/multiple-choice#one-of) property, which represents a dropdown menu.

For the sake of illustration, we also provide a `data` value containing some defaults that our UI should show.
This property can be omitted.

```typescript title="Data mapping with JSON forms"
import axios from "axios";
import { dataSource, util } from "@-io/spectral";

interface User {
  id: number;
  name: string;
  email: string;
}

interface Task {
  id: number;
  title: string;
}

const userTaskExample = dataSource({
  dataSourceType: "jsonForm",
  display: {
    label: "User/Task Mapper",
    description: "Map users to to-do tasks",
  },
  inputs: {},
  perform: async (context, params) => {
    const { data: users } = await axios.get<User[]>(
      "https://jsonplaceholder.typicode.com/users"
    );
    const { data: tasks } = await axios.get<Task[]>(
      "https://jsonplaceholder.typicode.com/todos?_limit=10"
    );

    const schema = {
      type: "object",
      properties: {
        mymappings: {
          // Arrays allow users to make one or more mappings
          type: "array",
          items: {
            // Each object in the array should contain a user and task
            type: "object",
            properties: {
              user: {
                type: "string",
                // Have users select "one of" a dropdown of items
                oneOf: users.map((user) => ({
                  // JSON Forms expects a string value:
                  const: util.types.toString(user.id),
                  title: user.name,
                })),
              },
              task: {
                type: "string",
                oneOf: tasks.map((task) => ({
                  const: util.types.toString(task.id),
                  title: task.title,
                })),
              },
            },
          },
        },
      },
    };

    const uiSchema = {
      type: "VerticalLayout",
      elements: [
        {
          type: "Control",
          scope: "#/properties/mymappings",
          label: "User <> Task Mapper",
        },
      ],
    };

    // Provide a default value, mapping of the first user to the first task
    const defaultValues = {
      mymappings: [
        {
          user: util.types.toString(users[0].id),
          task: util.types.toString(tasks[0].id),
        },
      ],
    };

    return {
      result: { schema, uiSchema, data: defaultValues },
    };
  },
});
```

The resulting JSON Form looks like this:

<Screenshot
  filename="custom-components/writing-custom-components/json-forms/data-mapping-json-form-result.png"
  maxWidth="600px"
  alt="Data mapping JSON form result"
/>

### Using existing component connections in data sources

You may want to extend an existing component to populate a config variable.
For example, you may want to fetch and filter specific information from a CRM or ERP and present the data to your user as a picklist menu.
Your data source can reference any existing connection config variable - including those from built-in components.

To use an existing component's connection, reference its connection's key names.
The [AWS Glue component](components/aws-glue.mdx) , for example, has an `accessKeyId` and `secretAccessKey`.
Your data source can reference those with:

```ts
{
  perform: async (context, params) => {
    const { accessKeyId, secretAccessKey } = params.myConnection.fields;
  };
}
```

The field that you likely need to use for OAuth 2.0 connections is the connection's `access_token`, which is nested under `token` like this:

```ts
{
  perform: async (context, params) => {
    const myAccessToken = params.myConnection.token.access_token;
  };
}
```

An example of reusing existing connections is available in the [Building a Field Mapper Data Source](quickstarts/field-mapping-json-forms-datasource.mdx) tutorial which covers pulling down custom fields from Salesforce.

## Branching in custom actions and triggers

Similar to the [branch](components/branch.mdx) component, your custom actions and triggers can make use of logical branches.
To support branches, give your `action()` or `trigger()` two additional properties, `allowsBranching: true` and `staticBranchNames: ["List", "Of", "Branches"]`, and ensure that the object that your `perform` function returns includes a `branch` property:

```typescript {9,10,18} title="Example action with branching"
export const branchExample = action({
  display: {
    label: "Branch Example",
    description: "An example action that branches",
  },
  inputs: {
    myValue: input({ label: "My Value", type: "string", required: true }),
  },
  allowsBranching: true,
  staticBranchNames: ["First", "Second", "Other"],
  perform: async (context, params) => {
    let branchName = "Other";
    if (params.myValue === "One") {
      branchName = "First";
    } else if (params.myValue === "Two") {
      branchName = "Second";
    }
    return await Promise.resolve({ branch: branchName, data: null });
  },
});
```

Similar code can be used in a custom trigger.
`allowsBranching: true` indicates to the integration designer that it should render branches beneath your action or trigger.
`staticBranchNames` is an array of strings representing names of possible branches that can be followed.
The branch name that matches the `branch` return value will be followed.

<Screenshot
  filename="custom-components/writing-custom-components/custom-branch-logs.png"
  maxWidth="800px"
  alt="Logs showing which branch was followed in a custom branch step"
  caption="Execution logs will always indicate which branch of a branching step was followed."
/>

## Handling binary files in custom components

Integrations in generally process serialized JSON, XML or other simple strings and pass deserialized JavaScript objects between steps.
But, there are situations when you may want to process and pass binary data between steps.
By "binary data", we mean files that are not plain text - PDF files, images, MP3 audio, etc.

Within an integration, a binary file is represented by its `contentType` (MIME type), and a `Buffer` that contains the file's data.
See Mozilla's documentation for a list of common file [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types).

```ts
{ data: Buffer.from("..."), contentType: "application/pdf" };
```

### Processing binary data as an input

Inputs for binary files are similar to any other input you might create, though you can use the `util.types.toData` function to ensure that the input has the form `{ data: Buffer, contentType: string }`:

```ts
{
  inputs: {
    myFile: input({
      label: "My File",
      type: "data",
      required: true,
      clean: util.types.toData,
    });
  }
}
```

The `myFile` property that comes in to your `perform` function will have the form of a binary file, with `data` and `contentType` properties that you can reference.

```ts
{
  perform: async (context, params) => {
    const { data: fileData, contentType } = params.myFile;
    // Send the data to an endpoint
    axios.post("http://my-endpoint", fileData, {
      headers: { "Content-Type": contentType },
    });
  };
}
```

### Returning binary data from an action

To return a binary file, from your action, ensure that the data you return is a `Buffer` and optionally include a `contentType` property alongside `data` that indicates its MIME type.
For example, if your custom component returns a rendered PDF file and the PDF contents are saved in a `Buffer` variable named `pdfContents`, the return block might look like this:

```typescript
return {
  data: pdfContents,
  contentType: "application/pdf",
};
```

You can return multiple files, or binary files in a nested object with a similar structure:

```typescript
return {
  myKey: "myValue",
  myPdf: {
    data: pdfBuffer,
    contentType: "application/pdf",
  },
  myPng: {
    data: pngBuffer,
    contentType: "image/png",
  },
};
```

### Fetching binary data with the Spectral HTTP client

When fetching binary data from an API, you must configure your HTTP client to expect binary data and to write the data to a `Buffer`.
For the HTTP client (which is Axios-based), use the `responseType: "arraybuffer"` configuration option to ensure the `data` property returned is a `Buffer`:

```typescript
{
  perform: async (context, params) => {
    const client = createBambooClient(params.connection);
    const { data, headers } = await client.get(`/v1/files/${params.fileId}`, {
      responseType: "arraybuffer",
    });
    return { data, contentType: headers["content-type"] };
  };
}
```

## Publishing a component

Package a component with `webpack` by running `npm run build` or `yarn build`:

```bash
$ yarn build
yarn run v1.22.10
$ webpack
asset icon.png 94.2 KiB [compared for emit] [from: assets/icon.png] [copied]
asset index.js 92.2 KiB [emitted] (name: main)
runtime modules 1.04 KiB 5 modules
modules by path ./node_modules/@-io/spectral/ 49.6 KiB
  modules by path ./node_modules/@-io/spectral/dist/types/*.js 3.92 KiB 12 modules
  modules by path ./node_modules/@-io/spectral/dist/*.js 21.4 KiB
    ./node_modules/@-io/spectral/dist/index.js 4.21 KiB [built] [code generated]
    ./node_modules/@-io/spectral/dist/util.js 11.9 KiB [built] [code generated]
    ./node_modules/@-io/spectral/dist/testing.js 5.29 KiB [built] [code generated]
  ./node_modules/@-io/spectral/node_modules/jest-mock/build/index.js 24.2 KiB [built] [code generated]
modules by path ./node_modules/date-fns/ 16 KiB
  modules by path ./node_modules/date-fns/_lib/ 780 bytes
    ./node_modules/date-fns/_lib/toInteger/index.js 426 bytes [built] [code generated]
    ./node_modules/date-fns/_lib/requiredArgs/index.js 354 bytes [built] [code generated]
  4 modules
./src/index.ts 2.46 KiB [built] [code generated]
./node_modules/valid-url/index.js 3.99 KiB [built] [code generated]
webpack 5.41.1 compiled successfully in 1698 ms
✨  Done in 2.86s.
```

This will create a `dist/` directory containing your compiled JavaScript and icon image.
Now use `prism` to publish your component.
If you do not have 's CLI tool, `prism`, installed, please take a moment to look through the [Prism overview page](cli/cli-usage.mdx).

```bash
$ prism components:publish

Format Name - Format a person's name given a first, middle, and last name
Would you like to publish Format Name? (y/N): y
Successfully submitted Format Name (v6)! The publish should finish processing shortly.
```

## Upgrading spectral versions

We release minor, non-breaking changes to Spectral often, and major changes periodically.
Major changes come with major version bumps (1.x.x, 2.x.x, 3.x.x, etc).

To upgrade a component from an older major version of spectral to a new one, see our upgrade guides:

- [Spectral 2.x upgrade guide](spectral/spectral-2-upgrade-guide.mdx)
- [Spectral 3.x upgrade guide](spectral/spectral-3-upgrade-guide.mdx)
- [Spectral 4.x upgrade guide](spectral/spectral-4-upgrade-guide.mdx)
- [Spectral 5.x upgrade guide](spectral/spectral-5-upgrade-guide.mdx)
- [Spectral 6.x upgrade guide](spectral/spectral-6-upgrade-guide.mdx)

If you are building a new component, we strongly encourage you to start with the latest version of Spectral.
