---
id: building-integrations
title: Diseñador de integración
description: Examine todas las funciones del diseñador de integración
---

import Icon from "@mui/material/Icon";
import InternalLink from "@site/src/components/internal-link";
import Screenshot from "@site/src/components/screenshot";
import SlugifyBox from "@site/src/components/slugify-box";
import Vimeo from "@site/src/components/vimeo";

Después de [crear una nueva integración](integrations.mdx#creating-a-new-integration) o seleccionar una de tu lista de integraciones, te encontrarás en el **diseñador de integraciones**. Aquí puedes construir, probar y publicar integraciones.

El diseñador de integraciones contiene cuatro características importantes:

1. El cajón de configuración te permite configurar pasos de tu integración, cambiar la configuración de tiempo de ejecución/webhook, etc.
2. El cajón de pruebas te permite [ejecutar pruebas de tu integración](testing-integrations.mdx), suministrar a tu integración con ejemplos de carga útil y ver los resultados de tus ejecuciones de prueba de integración.
3. El cajón de historial de versiones te permite publicar una versión de tu integración para que pueda ser implementada en clientes.
4. La mayor parte de la página está ocupada por el panel del editor de integraciones. Aquí, puedes agregar pasos a tu integración, crear ramas y bucles, y organizar generalmente el flujo de tu integración. También puedes crear múltiples **flujos**, cada uno con un [desencadenante](integration-triggers.mdx) y una serie de pasos que se ejecutarán.


<Screenshot
  filename="integrations/integration-designer.png"
  maxWidth="800px"
  alt="Diseñador de integración que destaca el cajón de configuración, el cajón de pruebas, el cajón del historial de versiones y el panel del editor de integración."
/>

## Pasos de la integración

Las acciones, como descargar un archivo desde un [servidor SFTP](components/sftp.mdx) o enviar un mensaje a [Slack](components/slack.mdx), se añaden como **pasos** de una integración.
Los pasos se ejecutan en orden, y las salidas de un paso pueden usarse como entradas para pasos subsecuentes.

Los pasos se ejecutan en orden de arriba a abajo, y puedes agregar lógica condicional a tu integración con una [rama](#branching) o ejecutar una serie de pasos en un conjunto de datos en un [bucle](#looping).
Si un paso genera un error, la integración se detiene.

### El paso de desencadenante

El primer paso de tu integración es el paso de **desencadenante**, que determina cuándo se ejecutarán las instancias de tu integración.
El artículo [Desencadenadores de integración](integration-triggers.mdx) detalla cómo funcionan los desencadenadores y cómo invocar tu integración.

### Añadir pasos a las integraciones

Para añadir un paso a una integración, haz clic en el icono <Icon>add_circle</Icon> debajo del desencadenante o de otra acción.

Selecciona el componente y la acción que deseas añadir a tu integración.
Por ejemplo, puedes elegir el componente **Amazon DynamoDB** y luego seleccionar la acción **Crear elemento**.
Puedes comenzar a escribir el nombre del componente o la acción que deseas añadir para filtrar la lista de componentes y acciones disponibles.


<Screenshot
  filename="integrations/add-step.png"
  maxWidth="500px"
  alt="Elija un componente o una acción para añadir un paso en la aplicación"
/>

### Pasos de la clonación

Si desea hacer una copia de un paso en su integración, abra el cajón de configuración del paso haciendo clic en el paso y, a continuación, seleccione el botón **clonar paso**.

<Screenshot
  filename="integrations/clone-step.png"
  alt="Clonar un paso en app"
  maxWidth="450px"
/>

Esto copiará el paso, incluyendo cualquier entrada que haya configurado para la acción.

### Cambio de acciones de paso

Si desea cambiar la acción que utiliza un paso, abra el cajón de configuración del paso haciendo clic en el paso y, a continuación, seleccione el botón **cambiar paso**.

<Screenshot
  filename="integrations/change-step-action.png"
  alt="Cambiar la acción de un paso en la aplicación"
  maxWidth="470px"
/>

Se le pedirá que seleccione una acción diferente y, a continuación, se le pedirá que rellene las entradas de esa nueva acción.

### Resultados de los pasos

Cuando se ejecuta un paso, opcionalmente emite datos que pueden utilizarse como entrada para los pasos siguientes.

Por ejemplo, un paso SFTP **List Files** mostrará una matriz de nombres de archivos:

<Screenshot
  filename="integrations/step-output-0.png"
  maxWidth="700px"
  alt="Ejemplo de salida de pasos en forma de lista en la aplicación"
/>

Un paso SFTP **Get File** mostrará el contenido de un archivo que ha obtenido de un servidor SFTP (en este caso, una imagen):

<Screenshot
  filename="integrations/step-output-1.png"
  maxWidth="700px"
  alt="Ejemplo de salida de pasos como archivo en app"
/>

Los resultados pueden ser de tres tipos:

- Un valor primitivo, como una **cadena de texto**, un **valor booleano**, un **número** o un **conjunto de valores primitivos**.
  Un paso subsecuente que haga referencia a esta salida recibirá la cadena de texto, el valor booleano, el número o el conjunto como entrada.
- Un **objeto**.

  Una salida puede incluir varios pares clave-valor:

  ```json
  { "key1": "value1", "key2": ["value2.0", "value2.1", "value2.2"] }
  ```

  Esto puede ocurrir al extraer JSON desde un punto de conexión HTTP.
  Los valores específicos de un objeto pueden ser referenciados como entradas utilizando la conocida notación de JavaScript con puntos `.dot` y corchetes `["bracket"]`.
  Usando el ejemplo anterior, si quisieras acceder a `value2.1`, podrías hacer referencia a `results.key2[1]`.


- Un **archivo binario**.
  Las salidas de archivos binarios contienen una combinación de un `Buffer` de archivo y un indicador del tipo de contenido (como `"image/png"`) en la forma:


  ```json
  {
    "data": Buffer,
    "contentType": String
  }
  ```

Nota: una acción puede devolver una combinación de JSON y archivo(s) binario(s) si las propiedades del objeto JSON son objetos con propiedades `data` y `contentType`.


**Para más información**:
[Resultados de Acciones de Componentes Personalizados](custom-components/writing-custom-components.mdx#action-results)


### Configuración de las entradas escalonadas

Una vez que hayas agregado un paso a tu integración, es probable que necesites configurar algunos inputs para ese paso. Los inputs pueden incluir una URL de punto final RESTful, el nombre de un cubo S3, un webhook de Slack para invocar, o incluso un archivo binario como una imagen o PDF para cargar o procesar.

Algunos inputs son obligatorios y están indicados con un símbolo `*`, mientras que otros son opcionales.

Los inputs pueden tomar una de cuatro formas: **valor**, **referencia**, **variable de configuración** o **plantilla**. Los inputs de **valor** son cadenas estáticas, los inputs de **referencia** hacen referencia a los resultados de un paso anterior, los inputs de **variable de configuración** hacen referencia a una variable de configuración específica del cliente, y los inputs de **plantilla** te permiten concatenar cadenas estáticas, variables de configuración y referencias a resultados de pasos.


#### Entradas de valor

Un **valor** es una cadena simple (quizás una URL para una solicitud HTTP). Si estableces un **valor** para un input, ese valor estático se utilizará como input para todos tus clientes:


<Screenshot
  filename="shared/component-input-value.png"
  maxWidth="600px"
  alt="Establecer valor de entrada en app"
/>

#### Entradas de referencia

Una **referencia** es una referencia a la salida de un paso anterior.
Por ejemplo, si un paso anterior descarga un archivo de Amazon S3 y el paso se llama **Fetch my file**, entonces puedes hacer referencia a **Fetch my file** como un input para otro paso, y ese paso subsiguiente recibirá el archivo que devolvió **Fetch my file**.

Las salidas de un paso pueden ser referenciadas por un paso subsiguiente al hacer referencia al campo **results** del paso anterior.
Así que, si un paso anterior devolvió un objeto, por ejemplo, si una acción **HTTP - GET** descargó algún JSON que lee `{ "firstkey": "firstvalue", "secondkey": "secondvalue" }`, puedes acceder a esa propiedad `secondvalue` en un input de un paso subsiguiente seleccionando el paso **HTTP - GET** y eligiendo `results.secondkey` en tu **Búsqueda de referencia**:


<Screenshot
  filename="shared/component-input-reference.png"
  maxWidth="650px"
  alt="Referencia al resultado de un paso anterior como entrada del paso en la aplicación"
/>

#### Configurar entradas variables

Una **variable de configuración** hace referencia a una de las variables de configuración de la integración.
Por ejemplo, podemos seleccionar una variable de configuración, `CMS API Endpoint`, como un input para uno de nuestros pasos.
Las variables de configuración pueden ser distintas para cada cliente, por lo que cada cliente puede configurarse con un `CMS API Endpoint` diferente:

<Screenshot
  filename="shared/component-input-config-var.png"
  maxWidth="500px"
  alt="Configurar entradas variables en la aplicación"
/>

#### Entradas de plantillas

Finalmente, una **plantilla** es una combinación de valores de cadena, variables de configuración o referencias a resultados de pasos.
Puedes concatenar varias cadenas, variables de configuración y resultados de pasos para que sirvan como una sola entrada.

Las plantillas son útiles si se necesita plantillar una entrada a partir de diversas variables de configuración y resultados de pasos.
Por ejemplo, supongamos que deseas realizar una solicitud HTTP a un punto final de API que se almacena como una variable de configuración y recuperar un elemento cuya identificación se obtuvo en un paso anterior.

Puede combinar el punto final de la API, la ruta URL y el ID del producto de la siguiente manera:

<Screenshot
  filename="integrations/template-input.png"
  maxWidth="550px"
  alt="Añadir entrada de plantilla en la aplicación"
/>

Una cadena estática, como `/product?id=`, se puede entremezclar con variables de configuración y referencias a resultados de pasos.

Puedes agregar referencias a variables de configuración o resultados de pasos haciendo clic en el botón **AGREGAR CAMPO DE PLANTILLA**.


<Screenshot
  filename="integrations/template-input-add-reference.png"
  maxWidth="600px"
  alt="Plantilla de entradas en la aplicación"
/>

**Para más información**:
[Entradas de componentes personalizados](custom-components/writing-custom-components.mdx#adding-inputs)


### Cambiar los nombres de los pasos

Por defecto, las etapas tienen nombres únicos después de la acción que invocan (por ejemplo, tienen nombres como **CSV a YAML**, o **Eliminar objeto**).
Para anular ese nombre predeterminado, haz clic en la etapa y luego en el nombre predeterminado para editarlo.

Al igual que usar nombres descriptivos de variables en un programa, cambiar el nombre de las etapas te permite darles nombres descriptivos.
Por ejemplo, en lugar de que una etapa se llame **Eliminar objeto**, puedes llamarla **Eliminar archivo de esquemas de Share**.
Recomendamos dar nombres descriptivos a tus etapas para que los miembros del equipo puedan leer las integraciones y comprender su propósito más fácilmente.

Si las etapas posteriores hacen referencia a los resultados de la etapa renombrada como entradas, esas referencias se actualizan automáticamente.

Si tiene pasos de código que hacen referencia a los resultados del paso renombrado, verá un mensaje bajo el nombre del paso renombrado:

<Screenshot
  filename="integrations/rename-step-code-diff-1.png"
  maxWidth="800px"
  alt="Posible cambio de código en la aplicación"
/>

Si hace clic en **Ver Opciones** se encontrará en una herramienta de diferencias que le recomendará cambios en su código, por lo que las referencias a los resultados del paso renombrado seguirán funcionando.
Realice los cambios que considere oportunos y haga clic en **Actualizar** para aplicar los cambios.

<Screenshot
  filename="integrations/rename-step-code-diff-2.png"
  maxWidth="700px"
  alt="Herramienta de diferencia de código en la aplicación"
/>

### Reordenar los pasos

Los pasos se ejecutan en serie.
Para reordenar los pasos, haga clic y arrastre un paso hacia arriba o hacia abajo.

<Screenshot
  filename="integrations/reorder-steps.webp"
  maxWidth="350px"
  alt="Reordenar los pasos del flujo en la aplicación"
/>

### Elección de las versiones de los componentes

Los componentes están [versionados](components.mdx#component-versions).
Puedes elegir una versión de cada componente (ya sea personalizado o integrado) que funcione para tu integración.
"Fijar" las versiones de los componentes para tu integración evita regresiones accidentales si se publica una nueva versión de un componente que contiene cambios incompatibles.

Para elegir qué versión de cada componente usa tu integración, haz clic en el botón **Versiones de componentes** en el lado derecho del diseñador de integraciones.

Puedes optar por ejecutar la última versión de un componente o cualquier versión anterior.
Los componentes que ejecutan la versión más reciente disponible se marcarán en gris, mientras que los componentes que ejecutan una versión para la cual hay una versión más nueva disponible se marcarán en amarillo.


<Screenshot
  filename="shared/component-version-drawer.png"
  maxWidth="350px"
  alt="Lista de versiones de componentes que resalta la última versión en la aplicación"
/>

Para cambiar la versión de un componente que utiliza su integración, haga clic en el botón **CAMBIAR VERSIÓN** situado a la derecha del componente que desea cambiar y seleccione una versión en el desplegable.

**Para más información**:
[Versionado de componentes](components.mdx#component-versioning)

## Tratamiento de errores de paso

A veces, un paso en una integración genera un error.
Esto puede deberse a una variedad de factores externos, como problemas temporales de conectividad de red, interrupciones breves en API de terceros, etc.
Es posible que no desees que toda tu integración se detenga porque un paso falló, especialmente si estás iterando sobre cientos de elementos y uno de ellos tiene problemas.

Puedes configurar cómo debe manejar el runner de la integración los errores en cada paso.
Para hacerlo, haz clic en un paso que te gustaría configurar y luego abre la pestaña **Manejo de errores** en el cajón de la izquierda.


En **Error Handler Type** tiene tres opciones:

- **Fail**: detiene la integración y genera un error.
- **Ignore**: ignora el error y continúa ejecutando el resto del flujo.
- **Retry**: espera una cantidad de tiempo (**Segundos entre intentos**) y luego vuelve a intentar el paso, un máximo de **Intentos máximos** veces. Opcionalmente, espera más tiempo entre cada reintento (**Retraso exponencial**, el doble de tiempo cada vez). Si el último intento todavía falla, ya sea que falle la integración o se ignore el error dependiendo de si **Ignorar error final** es verdadero o falso.


<Screenshot
  filename="integrations/step-level-error-handling.png"
  maxWidth="500px"
  alt="Captura de pantalla de la configuración de la gestión de errores por pasos"
/>

### Bifurcación tras errores ignorados

Si un paso está configurado para **Ignorar** errores, o si el paso ha intentado el número configurado de veces y luego ha ignorado el error final, el paso devuelve un resultado con una propiedad `error` que detalla el error que ocurrió.
Puedes utilizar el componente [branch](components/branch.mdx) para ramificar según ese error.

Esto es útil si tienes algún tipo de [cola de mensajes no entregados](https://es.wikipedia.org/wiki/Dead_letter_queue) para escribir el elemento que falló, o si deseas notificar a alguien sobre el elemento problemático.
Puedes ramificar según si `results.error` **existe** o no, y actuar en consecuencia.


<Screenshot
  filename="integrations/branch-on-step-error.png"
  alt="Captura de pantalla de la bifurcación en la gestión de errores a nivel de paso"
/>

## Flujos en las integraciones

<!-- <Vimeo video="591101878" title="Cómo utilizar varios flujos en una integración" /> -->

Algunas integraciones tienen un solo **flujo** (un solo desencadenante y una serie de pasos que se ejecutan).
Si tienes varios flujos lógicos relacionados, por ejemplo, si estás integrando con Acme ERP y Acme ERP está configurado para enviar una variedad de cargas útiles de webhook, puedes combinar varios flujos en una sola integración, un flujo para manejar cada tipo de webhook.
En lugar de implementar una docena de instancias distintas para cada uno de tus clientes para integrarse con Acme ERP, es más manejable implementar una sola integración que consta de varios flujos.

Las [variables de configuración](#config-variables-in-integrations) de una integración tienen alcance para la integración.
Entonces, una variable de configuración establecida para una integración se comparte y puede ser referenciada por cualquiera de los flujos de la integración.
Cada flujo tiene su propio desencadenante único y, por lo tanto, tiene su propia [URL de webhook](integration-triggers.mdx#webhook-triggers) que puedes usar para invocar ese flujo específico.


### Gestión de los flujos de integración

Para añadir un nuevo flujo a su integración, haga clic en el botón **+ Añadir flujo** en la parte superior del diseñador.

<Screenshot
  filename="integrations/manage-flows.png"
  maxWidth="500px"
  alt="Gestionar los flujos de integración en la aplicación"
/>

Para editar un flujo, haz clic en el nombre de tu flujo actual y luego haz clic en el ícono de lápiz a la derecha de un flujo.
Cada flujo debe tener un nombre único y puede tener una descripción opcional.

Para eliminar un flujo de una integración, haz clic en el ícono de papelera a la derecha del nombre y la descripción del flujo.

### Clonar un flujo

Si necesitas agregar un flujo similar a otro que ya has construido, es útil poder **clonar** (hacer una copia de) un flujo.
Para clonar un flujo, abre el menú del flujo haciendo clic en el nombre de tu flujo en la parte superior izquierda del diseñador de integraciones.
Luego, selecciona el botón de clonar flujo y dale a tu copia un nuevo nombre.


<Screenshot
  filename="integrations/clone-flow.png"
  maxWidth="340px"
  alt="Clonar el flujo de integración en la aplicación"
/>

### Probar y ejecutar flujos

Cada flujo se ejecuta de forma independiente y tiene su propio desencadenante.
También se prueban de forma independiente.
Para probar un flujo, haz clic en el botón de selección de flujo en la parte superior izquierda del área del diseñador de integraciones y selecciona el flujo que deseas probar.
Luego, [ejecuta pruebas](testing-integrations.mdx) de la misma manera que lo harías con una integración de un solo flujo.

## Variables de configuración en integraciones

Cuando tu cliente configura y activa una instancia de tu integración, pasarán por un [asistente de configuración de instancias](configuration-wizard.mdx) donde ingresarán la autenticación con aplicaciones de terceros, seleccionarán opciones de menús desplegables, mapearán campos, alternarán valores booleanos, etc.

Tu integración puede hacer referencia a las variables de configuración que configura tu cliente, y como creador de la integración, puedes personalizar la experiencia del asistente de configuración para tus clientes.


Para obtener información sobre cómo construir una experiencia de asistente de configuración para tus usuarios, consulta el artículo [Asistente de Configuración](configuration-wizard.mdx).


## Sincrónico / asincrónico

Las integraciones pueden activarse de forma síncrona o asíncrona. Para obtener más información, consulta el artículo sobre [desencadenadores de integración](integration-triggers.mdx#integraciones-sincronas-y-asincronas).


## Configuración del reintento de integración

:::info Se requiere un plan Professional o Enterprise
Para configurar la reintegración de la integración, necesitarás tener un plan Professional o Enterprise. Los detalles del plan están disponibles en nuestra <InternalLink href="/pricing/">página de precios</InternalLink>.

:::

Puedes configurar tus instancias invocadas [de forma asíncrona](integration-triggers.mdx#synchronous-and-asynchronous-integrations) para que se vuelvan a intentar si no se ejecutan completamente.
Esto es útil si tu integración depende de una API de terceros inestable: la API de terceros podría estar fuera de servicio brevemente, pero volver a estar en funcionamiento unos minutos después.
Puedes configurar tu integración para que vuelva a intentarlo en unos minutos cuando la API esté nuevamente en funcionamiento, sin necesidad de activar innecesariamente alertas para tu equipo.


<!-- <Vimeo title="Cómo configurar una integración para que reintente" video="507722700" /> -->

Para configurar una integración para que reintente su ejecución, haga clic en su activador y, a continuación, en **Reintentar flujo**.

<Screenshot
  filename="integrations/configure-retry.png"
  maxWidth="800px"
  alt="Establecer la integración para reintentar en la aplicación"
/>

**Intentos de Reintento** indica el número máximo de intentos (hasta 5) que se ejecutarán en la misma instancia en caso de fallo.
Si una instancia ha fallado más de **Intentos de Reintento**, la ejecución se marcará como _fallida_ y se activarán los correspondientes [monitores de alerta](monitoring-and-alerting.mdx), si están configurados.

**Minutos Entre Intentos** indica la cantidad de minutos que deben transcurrir antes de intentar ejecutar una instancia nuevamente.
Si, por ejemplo, especificas **4** minutos y la primera invocación de la instancia falló a las 10:24, entonces la instancia intentará ejecutarse nuevamente a las 10:28, 10:32, 10:36, 10:40 y 10:44 si continúa fallando en completarse.

_Nota:_ Debido a la naturaleza de las funciones Lambda de AWS programadas, los reintentos programados son precisos hasta el minuto (en lugar del segundo).
Así que, un intento que falla a las 10:24 con un **Minutos Entre Intentos** configurado en 4 podría activarse nuevamente a las 10:28 o 10:29.


Si tienes seleccionada la opción de **Espera Exponencial**, tu instancia esperará un tiempo cada vez más largo entre intentos, utilizando un factor exponencial de 2.
Por ejemplo, si tu **Minutos Entre Intentos** está configurado en 3 y se selecciona **Espera Exponencial**, entonces los intentos de reintento se activarán después de 3, 6, 12, 24 y 48 minutos.

_Nota_: El tiempo máximo que una instancia esperará antes de intentar nuevamente es de **24 horas**.
Si el cálculo de la espera excede las 24 horas, se activará después de esperar 24 horas en su lugar.

Finalmente, **Cancelación de Reintentos** te da la capacidad de cancelar un conjunto de intentos de reintento si se produce una invocación más reciente de la instancia.
Por ejemplo, si tu integración recibe un paquete de datos como parte de su invocación y luego actualiza algún sistema de terceros con esos datos, es posible que desees cancelar invocaciones más antiguas si llegan datos más nuevos.
De lo contrario, podrías terminar actualizando algún sistema de terceros con datos más nuevos y luego el reintento sobrescribiría los datos más nuevos con datos más antiguos.


Para configurar la cancelación de reintento, selecciona un identificador único de solicitud del payload del disparador.
Por ejemplo, podrías pasar un encabezado, `x-my-unique-id: abc123`, como parte de tu payload del disparador.
Si llega otra invocación con ese encabezado que actualiza el recurso `abc123`, es posible que desees cancelar los reintentos actualmente en cola.
Para hacerlo, selecciona la referencia `results.headers.results.headers.x-my-unique-id` de tu disparador como tu **Identificador Único de Cancelación**.


No es necesario que los ID de cancelación sean cabeceras.
En su lugar, puede seleccionar una clave del cuerpo de la carga útil.
Por ejemplo, si su invocación de instancia tiene este aspecto:

```
curl 'https://hooks..io/trigger/EXAMPLE==' \
  --location \
  --header "Content-Type: application/json" \
  --data '{"productId":"abc123","price":"250","description":"A box of widgets"}'
```

Puedes utilizar `results.body.data.productId` como tu identificador único de cancelación.


**Para más información**:
[Reintento y repetición de instancias](instances.mdx#instance-execution-retry-and-replay)

## Bucle

<!-- <Vimeo title="Cómo hacer un bucle sobre archivos en una integración" video="502284421" /> -->

Para muchas integraciones, es útil poder iterar sobre una matriz de elementos o hacerlo un cierto número de veces. Si tu integración procesa archivos en un servidor SFTP, por ejemplo, es posible que desees iterar sobre una matriz de archivos en el servidor. Si tu integración envía alertas a los usuarios, es posible que desees iterar sobre una matriz de usuarios.

prism proporciona el [componente de bucle](components/loop.mdx) que te permite iterar sobre una matriz de elementos, o puedes hacerlo un número predeterminado de veces. Después de agregar un paso de **bucle** a tu integración, puedes agregar pasos dentro del bucle que se ejecutarán una y otra vez.

El componente **bucle** toma una entrada: los **elementos**.
**Elementos** es una matriz, una serie de números, cadenas, objetos, etc. Por ejemplo, un paso podría generar una matriz de archivos que tu integración necesita procesar.

El resultado podría ser el siguiente:

```json
[
  "path/to/file1.txt",
  "path/to/file2.txt",
  "path/to/file3.txt",
  "path/to/file4.txt"
]
```

El componente de bucle se puede configurar para iterar sobre esos archivos haciendo referencia a los `resultados` del paso **listar archivos**:


<Screenshot
  filename="integrations/loop.png"
  maxWidth="800px"
  alt="Recorrer archivos en bucle haciendo referencia a los resultados del paso Listar archivos de la aplicación"
/>

Pasos subsecuentes pueden hacer referencia a los parámetros `currentItem` e `index` del paso de bucle para obtener valores como `path/to/file3.txt` y `2` respectivamente:


<Screenshot
  filename="integrations/loop-current-item.png"
  maxWidth="800px"
  alt="Recorrer elementos para obtener rutas de archivos en la aplicación"
/>

**Para más información**:
[El Componente de Bucle](components/loop.mdx),
[Guía Rápida para Iterar Sobre Archivos](quickstarts/looping-over-files.mdx),
[Iterando sobre una API Paginada](quickstarts/looping-over-a-paginated-api.mdx)

### Iterando sobre listas de objetos

La lista de objetos pasada a un componente de bucle puede ser tan simple o compleja como desees.


En este ejemplo, si tenemos un bucle llamado **Loop Over Users**, y el bucle se presentó **items** en el formulario:

```json
[
  {
    "name": "Bob Smith",
    "email": "bob.smith@progix.io"
  },
  {
    "name": "Sally Smith",
    "email": "sally.smith@progix.io"
  }
]
```

Entonces, el bucle se ejecutará dos veces, una vez por cada objeto en la lista, y podemos escribir un componente de código que accede a los valores de `currentItem` e `index` del bucle y a las subpropiedades de `currentItem` de la siguiente manera:


```javascript
module.exports = async (
  { logger },
  { loopOverUsers: { currentItem, index } }
) => {
  logger.info(`User #${index + 1}: ${currentItem.name} - ${currentItem.email}`);
};
```

Esto registrará líneas como `Usuario #1: Bob Smith - bob.smith@.io`.

### Recorriendo una API paginada

Muchas API de terceros limitan la cantidad de registros que puedes recuperar a la vez y te permiten cargar un lote (o "página") de registros a la vez.
Es posible que necesites recorrer un número desconocido de páginas de registros en una integración.


Puedes lograrlo con una combinación de dos bucles (uno para recorrer las páginas y otro para recorrer los registros en cada página) y una acción [break loop](components/loop.mdx#break-loop) que detiene la carga de páginas cuando ya no quedan más por cargar:


<Screenshot
  filename="integrations/paginated-loop.png"
  maxWidth="550px"
  alt="Bucle sobre la API paginada en la aplicación"
/>

Consulta [esta guía rápida](quickstarts/looping-over-a-paginated-api.mdx) para ver un ejemplo de cómo recorrer una API paginada.

### Valores de retorno de los bucles

Un bucle recopilará los resultados del **último** paso dentro del bucle y los guardará como un array.

Por ejemplo, si el bucle recibe la lista de objetos de usuario formateados en JSON [anteriormente mencionada](#looping-over-lists-of-objects) y el último paso en el bucle es un componente de código que lee:


```javascript
module.exports = async(context, loopOverUsers: { currentItem }) => {
    return {data: `Processed ${currentItem.email}`}
}
```

Entonces, el `resultado` del bucle producirá:


```json
["Processed bob.smith@progix.io", "Processed sally.smith@progix.io"]
```

## Ramificación

El componente [branch](components/branch.mdx) te permite agregar lógica de ramificación a tu integración.
Piensa en las **ramas** como rutas lógicas que tu integración puede tomar.
Dada cierta información sobre variables de configuración o resultados de pasos, tu integración puede seguir una de muchas rutas.

Las acciones de rama son útiles cuando necesitas ejecutar pasos condicionalmente.
Aquí tienes algunos ejemplos de cosas que puedes lograr con ramificación:

**Ejemplo 1:** La solicitud de webhook que recibe tu integración podría contener una carga útil de "Orden creada", "Orden actualizada" o "Orden eliminada".
Necesitas ramificar en consecuencia.

**Ejemplo 2:** Tus clientes desean recibir una alerta cuando el nivel de combustible de su cohete esté por debajo de cierto umbral.
Puedes ramificar en "enviar una alerta" y "el nivel de combustible está bien" según los resultados de un paso de "verificar el nivel de combustible del cohete".

**Ejemplo 3:** Quieres realizar una [operación de actualización e inserción](<https://es.wikipedia.org/wiki/MERGE_(SQL)>) de datos en un sistema que no admite esta operación.
Puedes verificar si existe un registro y ramificar en "agregar un nuevo registro" o "actualizar el registro existente" según si el registro existe.


**Para más información**:
[El componente de rama](components/branch.mdx),


### Bifurcación en un valor

Agregar una acción [Branch on Value](components/branch.mdx#branchonvalue) a tu integración te permite crear un conjunto de ramas basadas en el valor de alguna variable en particular. Es muy similar a la estructura switch/case presente en muchos lenguajes de programación.


<!-- <Vimeo
  title="Cómo bifurcarse en un único valor en una integración"
  video="504463395"
/> -->

Consideremos el **ejemplo 1** anterior.
Supongamos que la solicitud de webhook que recibes tiene un encabezado, `payload-type`, que puede tener uno de tres valores: `order-create`, `order-update` u `order-delete`. Puedes mirar ese valor y ramificar en consecuencia.


<Screenshot
  filename="shared/branch-on-value.png"
  alt="Bifurcarse en el valor de la aplicación"
/>

**Para más información**:
[Rama de acción Valor](components/branch.mdx#branchonvalue)

### Bifurcación en una expresión

La acción [Branch on Expression](components/branch.mdx#branchonexpression) te permite crear ramas dentro de tu integración basadas en entradas más complejas. Puedes comparar valores, como variables de configuración, resultados de pasos o valores estáticos, y seguir una rama en función de los resultados de las comparaciones.


<!-- <Vimeo
  title="Cómo bifurcarse en una expresión en una integración"
  video="504487086"
/> -->

Consideremos el **ejemplo 2** anterior.
Usted tiene un paso que comprueba el nivel de combustible del cohete para un cliente, y desea alertar a los usuarios de diferentes maneras si sus niveles de combustible son bajos.
Puedes expresar este problema con un poco de pseudocódigo:

```python
if fuelLevel < 50:
    sendAnSMS()
else if fuelLevel < 100:
    sendAnEmail()
else:
    doNothing()
```

Para expresar este pseudocódigo en una integración, agrega un paso que consulte el nivel de combustible del cohete. Luego, agrega una acción **Branch on an Expression** a tu integración.

Crea una rama llamada **Fuel Critical** y en **Condition Inputs** verifica que los `resultados` del paso de verificación del nivel de combustible **sean menores que** 50.
Luego, crea otra rama llamada **Fuel Warning** y verifica que los `resultados` del paso de verificación del nivel de combustible **sean menores que** 100.

Esto generará un paso de ramificación que ejecutará la rama **Send Alert SMS** si los niveles de combustible son inferiores a 50, **Send Warning Email** si los niveles de combustible son inferiores a 100, o seguirá la rama **Else** si los niveles de combustible son iguales o superiores a 100.

<Screenshot
  filename="shared/branch-on-expression.png"
  alt="Rama en la expresión en la aplicación"
/>

### Rama sobre operadores de expresión

Puedes comparar variables de configuración, resultados de pasos anteriores o valores estáticos entre sí utilizando una variedad de operadores de comparación.
Estos operadores evalúan a `true` o `false`, y se pueden encadenar con las cláusulas **And** y **Or**.


- El operador **igual** evalúa si dos campos son iguales entre sí, independientemente del tipo.

  | Left Field      | Right Field     | Result  | Comments                                                       |
  | --------------- | --------------- | :-----: | -------------------------------------------------------------- |
  | `5.2`           | `5.2`           | `true`  |                                                                |
  | `5.2`           | `5`             | `false` |                                                                |
  | `"5.2"`         | `5.2`           | `true`  | Strings are cast to numbers when compared to numbers           |
  | `"Hello"`       | `"Hello"`       | `true`  |                                                                |
  | `"Hello"`       | `"hello"`       | `false` | String comparison is case-sensitive                            |
  | `false`         | `0`             | `true`  | Boolean `false` evaluates to `0`, and `true` evaluates to `1`. |
  | `[1,2,3]`       | `[1,2,3]`       | `true`  | Arrays whose elements are the same are considered equal        |
  | `{"foo":"bar"}` | `{"foo":"bar"}` | `true`  | Objects with the same keys/values are equal                    |

- El operador **no es igual** evalúa si dos campos son _no_ iguales entre sí, independientemente del tipo.

  | Left Field | Right Field | Result |
  | ---------- | ----------- | :----: |
  | `5.3`      | `5.2`       |  true  |
  | `[1,2,3]`  | `[1,2,4]`   |  true  |

- El operador **is greater than** evalúa si el campo izquierdo es mayor que el campo derecho, y es una implementación del [operador mayor que](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Greater_than) en JavaScript.


  | Left Field | Right Field | Result  | Comments                                                                       |
  | ---------- | ----------- | :-----: | ------------------------------------------------------------------------------ |
  | `5.2`      | `5.3`       | `false` |
  | `5.3`      | `5.3`       | `false` | The values are equal; one is not greater than the other                        |
  | `"5.3"`    | `5.2`       | `true`  | Strings are cast to numbers when compared to numbers                           |
  | `"Hello"`  | `"World"`   | `false` | Strings are compared alphabetically - `"Hello"` does not occur after `"World"` |
  | `"hello"`  | `"World"`   | `true`  | The ASCII value for `"h"` occurs [after](https://www.asciitable.com/) `"W"`    |
  | `true`     | `false`     | `true`  | `true` (1) is greater than `false` (0)                                         |

- El operador **is greater than or equal to** es similar a **is greater than**, pero también devuelve true si los valores comparados son iguales entre sí.


  | Left Field | Right Field | Result | Comments                                             |
  | ---------- | ----------- | :----: | ---------------------------------------------------- |
  | `5.3`      | `"5.3"`     | `true` | Strings are cast to numbers when compared to numbers |

- El operador **is less than** evalúa si el campo izquierdo es menor que el campo derecho.


  | Left Field | Right Field | Result | Comments                                |
  | ---------- | ----------- | :----: | --------------------------------------- |
  | `3`        | `4`         | `true` |                                         |
  | `"abc"`    | `"daa"`     | `true` | `"a"` is less than `"d"` alphabetically |

- El operador **is less than or equal to** es similar al **is less than**, pero también devuelve true si los valores comparados son iguales entre sí.
- El operador **contained in** evalúa si el valor del campo izquierdo está contenido en el campo derecho.
  El campo derecho debe ser un array o una cadena.

  | Left Field | Right Field       | Result  | Comments                                                          |
  | ---------- | ----------------- | :-----: | ----------------------------------------------------------------- |
  | `"world"`  | `"Hello, world!"` | `true`  |                                                                   |
  | `"World"`  | `"Hello, world!"` | `false` | String comparison is case-sensitive                               |
  | `2`        | `[1,2,3]`         | `true`  |
  | `"2"`      | `[1,2,3]`         | `false` | The string `"2"` does not occur in the array of numbers `[1,2,3]` |

- El operador **not contained in** evalúa si el valor del campo izquierdo no aparece en el campo derecho.


  | Left Field | Right Field | Result  |
  | ---------- | ----------- | :-----: |
  | `2`        | `[1,2,3]`   | `false` |
  | `'Hi'`     | `'Hello'`   | `true`  |

- El operador **is empty** evalúa si el valor dado es una cadena vacía o un array vacío.


  | Field     | Result  |
  | --------- | :-----: |
  | `""`      | `true`  |
  | `"hello"` | `false` |
  | `[]`      | `true`  |
  | `[1,2,3]` | `false` |

- El operador **exactly matches** evalúa si los dos campos son iguales entre sí, teniendo en cuenta el tipo de los valores.


  | Left Field | Right Field | Result  | Comments                                        |
  | ---------- | ----------- | :-----: | ----------------------------------------------- |
  | `"5"`      | `5`         | `false` | The string `"5"` is not equal to the number `5` |

- El operador **does not exactly match** evalúa si los dos campos no son iguales entre sí, teniendo en cuenta el tipo de los valores.


  | Left Field | Right Field | Result | Comments                                        |
  | ---------- | ----------- | :----: | ----------------------------------------------- |
  | `"5"`      | `5`         | `true` | The string `"5"` is not equal to the number `5` |

- El operador **starts the string** evalúa si el valor del campo derecho comienza con el valor del campo izquierdo.

  Tanto el valor derecho como el izquierdo deben ser cadenas.

  | Left Field | Right Field         | Result  | Comments                                                       |
  | ---------- | ------------------- | :-----: | -------------------------------------------------------------- |
  | `"Test"`   | `"Testing Value"`   | `true`  |                                                                |
  | `"test"`   | `"Testing Value"`   | `false` | Comparisons are case-sensitive                                 |
  | `"Test"`   | `"A Testing Value"` | `false` | The right field must start with (not _contain_) the left value |

- El operador **does not start the string** devuelve lo contrario del operador **starts with**.
- El operador **ends the string** evalúa si el campo derecho termina con el campo izquierdo.

  Tanto el valor derecho como el izquierdo deben ser cadenas.

  | Left Field | Right Field     | Result  |
  | ---------- | --------------- | :-----: |
  | `orld!`    | `Hello, World!` | `true`  |
  | `orld`     | `Hello, World!` | `false` |

- El operador **does not end the string** devuelve lo contrario del operador **ends with**.


:::note Formatos de Fecha y Hora Aceptados
Los siguientes tres operadores de comparación aceptan fechas y horas en formato ISO (como `2021-03-20` o `2021-03-20T11:52:21.881Z`), marcas de tiempo de época Unix en milisegundos (por ejemplo, el número `1631568050` representa una hora en 2021-09-13) o objetos JavaScript `Date()`.

:::

- El operador **es después de (fecha/hora)** intenta analizar los campos izquierdo y derecho como fechas, y evalúa si el campo izquierdo ocurre después del campo derecho.


  | Left Field                   | Right Field                  | Result  | Comments                                                                          |
  | ---------------------------- | ---------------------------- | :-----: | --------------------------------------------------------------------------------- |
  | `"2021-03-20"`               | `"2021-04-13"`               | `false` |                                                                                   |
  | `"2021-03-20T12:50:30.105Z"` | `"2021-03-20T11:52:21.881Z"` | `true`  | When dates are equivalent, time is compared                                       |
  | `"2021-03-20"`               | `1631568050`                 | `false` | `1631568050` is the UNIX epoch time for 2021-09-13, which occurs after 2021-03-05 |

- El operador **es antes de (fecha/hora)** intenta analizar los campos izquierdo y derecho como fechas, y evalúa si el campo izquierdo ocurre antes del campo derecho.
- El operador **es el mismo (fecha/hora)** intenta analizar los campos izquierdo y derecho como fechas, y evalúa si los sellos de tiempo son idénticos.


  | Left Field                   | Right Field                  | Result  | Comments                                                                               |
  | ---------------------------- | ---------------------------- | :-----: | -------------------------------------------------------------------------------------- |
  | `"2021-03-20T12:50:30.105Z"` | `"2021-03-20T12:50:30.105Z"` | `true`  |
  | `"2021-03-20T12:50:30Z"`     | `1616244630000`              | `true`  | `1616244630` is the millisecond UNIX epoch representation of `March 20, 2021 12:50:30` |
  | `"2021-03-20T12:50:30Z"`     | `"2021-03-20T12:50:31Z"`     | `false` |

- El operador **es verdadero** evalúa si un campo de entrada es "verdadero".


  Common "truthy" values include `true`, `"true"`, `"True"`, `"Yes"`, `"yes"`, `"Y"` and `"y"`.

  Common "falsy" values include `false`, `"false"`, `"False"`, `"No"`, `"no"`, `"N"` and `"n"` and evaluate to `false`.
  Other values that evaluate to `false` are `0`, `null`, `undefined`, `NaN` and `""`.

  All other values (a non-zero number, a non-empty string, any array or object, etc.) evaluates to `true`.

  | Field     | Result  |
  | --------- | :-----: |
  | `"Yes"`   | `true`  |
  | `"True"`  | `true`  |
  | `[]`      | `true`  |
  | `{}`      | `true`  |
  | `"Hello"` | `true`  |
  | `-5`      | `true`  |
  | `"n"`     | `false` |
  | `false`   | `false` |
  | `""`      | `false` |
  | `null`    | `false` |
  | `0`       | `false` |

- El operador **es falso** devuelve lo opuesto al operador **es verdadero**.
- El operador **no existe** evalúa a `verdadero` si el valor presentado es uno de los siguientes: `undefined`, `null`, `0`, `NaN`, `false` o `""`.


  | Field       | Result  |
  | ----------- | :-----: |
  | `undefined` | `true`  |
  | `NaN`       | `true`  |
  | `1`         | `false` |
  | `"Hello"`   | `false` |

- El operador **existe** devuelve lo opuesto al operador **no existe**.


### Combinación de varios operadores de comparación

Múltiples expresiones pueden agruparse con las cláusulas **And** o **Or**, que se ejecutan como las cláusulas **and** y **or** en programación. Considera, por ejemplo, esta expresión en programación:


```
if ((foo > 500 and bar <= 20) or ("b" in ["a","b","c"]))
```

La misma lógica se puede representar con un grupo de condicionales en una acción [Branch on Expression](components/branch.mdx#branchonexpression):


<Screenshot
  filename="shared/branch-on-expression-logic.png"
  maxWidth="500px"
  alt="Bifurcarse en una expresión utilizando condicionales en una aplicación"
/>

**Para más información**:
[Rama sobre la acción de expresión](components/branch.mdx#branchonexpression)

### Ramas convergentes

Independientemente de la rama que se siga, las ramas siempre convergen en un solo punto. Una vez que se ha ejecutado una rama, la integración continuará con el siguiente paso que se encuentra debajo de la convergencia de la rama.

Esto presenta un problema: ¿cómo hacen los pasos debajo de la convergencia para referenciar los pasos en ramas que pueden o no haberse ejecutado (dependiendo de qué rama se haya seguido)? En tu integración, es posible que desees decir "si se ejecutó la rama _foo_, obtén los resultados de _step A_, y si se ejecutó la rama _bar_, obtén en su lugar los resultados de _step B_". proporciona la acción [Select Executed Step Result](components/branch.mdx#select-executed-step-result) para manejar ese escenario.

Imagina que tienes dos ramas, una para facturas entrantes y otra para facturas salientes, cada una con lógica diferente. Independientemente de cuál rama se haya ejecutado, te gustaría insertar los datos resultantes en un sistema ERP. Puedes aprovechar la acción [Select Executed Step Result](components/branch.mdx#select-executed-step-result) para decir "dame la factura entrante o saliente, la que se haya ejecutado".


Esta acción itera sobre la lista de resultados de pasos que especificas y devuelve el primero que tiene un valor no nulo (lo que indica que se ejecutó).


<Screenshot
  filename="shared/select-executed-step-result.png"
  alt="Seleccionar el resultado del paso ejecutado mientras se ramifica en la aplicación"
/>

Dentro del cajón de configuración del componente, selecciona el o los pasos cuyos resultados te gustaría obtener, y el paso **Select Executed Step Result** proporcionará el resultado de aquel que se ejecutó.

## Persistir datos entre ejecuciones

A veces es útil guardar datos de una ejecución de una integración para que puedan utilizarse en una ejecución posterior. proporciona componentes que te permiten guardar algún estado de una ejecución para su uso en una ejecución futura.


¿Por qué es importante o útil?
Imagina que tienes una integración que descarga y procesa datos de una fuente de datos. Recientemente, tu integración procesó un registro con ID "123", y la próxima vez que se ejecute, deseas asegurarte de procesar ID "124" en adelante. Puedes persistir "123" utilizando una acción [Save Value](components/persist-data.mdx#flow---save-value), y luego, la próxima vez que se ejecute tu integración, puede utilizar [Get Value](components/persist-data.mdx#flow---get-value) para saber que "123" fue el registro procesado más recientemente. Luego puedes construir tu integración para procesar registros más nuevos que el que se guardó.


Veamos dos componentes que aprovechan la persistencia de datos:

### El componente de persistencia de datos

Los datos pueden persistirse entre ejecuciones utilizando el componente [Persist Data](components/persist-data.mdx). Los datos se almacenan en pares clave-valor, y los valores pueden ser cadenas, números, objetos o listas. Puedes elegir persistir datos con las acciones `Flow -` que te permite persistir datos con ámbito en el flujo actual. También puedes utilizar las acciones `Cross Flow -` para persistir datos que pueden compartirse entre flujos de una instancia. O puedes usar las acciones `Integration -` para persistir datos entre instancias de la misma integración (por lo tanto, varios clientes pueden compartir un almacén de datos).


Puedes almacenar un par clave/valor utilizando la acción [Save Value](components/persist-data.mdx#flow---save-value), o puedes usar otras acciones de [Persist Data](components/persist-data.mdx) para agregar a una lista persistida. Si prefieres guardar una marca de tiempo, puedes utilizar la acción [Save Current Time](components/persist-data.mdx#flow---save-current-time) para guardar la hora actual en una clave de tu elección.

Más tarde, en una ejecución posterior, puedes recuperar el valor que guardaste utilizando la acción [Get Value](components/persist-data.mdx#flow---get-value). Si una clave no está establecida, **Get Value** devolverá `null`.


Puedes eliminar datos de un array o quitar un par clave/valor por completo utilizando otras acciones de [Persist Data](components/persist-data.mdx).

### El componente de procesamiento de datos

Para algunas integraciones, es útil saber qué datos de un array ya has procesado y cuáles no. Por ejemplo, tu integración podría descargar un array de pedidos de una tienda de datos para convertirlos en facturas.

Su matriz de pedidos podría tener este aspecto:

```json
[
  {
    "orderid": 123,
    "items": {
      "widgets": 5,
      "whatsits": 7
    }
  },
  {
    "orderid": 122,
    "items": {
      "whoseits": 2
    }
  }
]
```

La acción [DeDuplicate](components/process-data.mdx#deduplicate) de Process Data te permite pasar un array de objetos en **orden descendente**, junto con un identificador único (como `orderid`).
La acción utiliza la persistencia de datos entre ejecuciones para rastrear el elemento más recientemente procesado (en este ejemplo, `"orderid": 123`).
La próxima vez que se ejecute esta integración y se pase un array de pedidos al paso **DeDuplicate**, el paso devolverá todos los objetos en el array que aparecen **antes** del objeto con `"orderid": 123`.
Así que, si hay un ID de pedido 124, 125, etc., devolverá esos.
De esta manera, la ejecución subsiguiente ignorará el ID de pedido 123 y anteriores, y procesará solo pedidos más recientes.


Para más información:
[Persistir Datos en Componentes Personalizados](custom-components/writing-custom-components.mdx#execution-instance-and-cross-flow-state)


## Interacción con las API SOAP

Un API de **Protocolo Simple de Acceso a Objetos** (SOAP) define cómo un cliente debe interactuar con el API a través de XML y un esquema llamado WSDL.
Para interactuar con un API basado en SOAP, puedes utilizar el componente genérico incorporado de [SOAP](components/soap.mdx) para obtener e interpretar el WSDL y realizar solicitudes al API, o puedes escribir tu propio componente personalizado aprovechando las [funciones de utilidad de SOAP](custom-components/writing-custom-components.mdx#soap-utility-functions) del SDK.